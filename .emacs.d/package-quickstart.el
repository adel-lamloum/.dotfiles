;;; Quickstart file to activate all packages at startup  -*- lexical-binding:t -*-
;; ¡¡ This file is autogenerated by `package-quickstart-refresh', DO NOT EDIT !!

(let ((load-true-file-name "/home/adel/.emacs.d/elpa/yaml-mode-20240317.1602/yaml-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/yaml-mode-20240317.1602/yaml-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(let ((loads (get 'yaml 'custom-loads))) (if (member '"yaml-mode" loads) nil (put 'yaml 'custom-loads (cons '"yaml-mode" loads)) (put 'languages 'custom-loads (cons 'yaml (get 'languages 'custom-loads)))))
(autoload 'yaml-mode "yaml-mode" "\
Simple mode to edit YAML.

\\{yaml-mode-map}

(fn)" t)
(add-to-list 'auto-mode-alist '("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))
(add-to-list 'magic-mode-alist '("^%YAML\\s-+[0-9]+\\.[0-9]+\\(\\s-+#\\|\\s-*$\\)" . yaml-mode))
(register-definition-prefixes "yaml-mode" '("yaml-"))


(provide 'yaml-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/which-key-20240501.1251/which-key-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/which-key-20240501.1251/which-key-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(defvar which-key-mode nil "\
Non-nil if Which-Key mode is enabled.
See the `which-key-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `which-key-mode'.")
(custom-autoload 'which-key-mode "which-key" nil)
(autoload 'which-key-mode "which-key" "\
Toggle which-key-mode.

This is a global minor mode.  If called interactively, toggle the
`Which-Key mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='which-key-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'which-key-setup-side-window-right "which-key" "\
Set up side-window on right." t)
(autoload 'which-key-setup-side-window-right-bottom "which-key" "\
Set up side-window on right if space allows.
Otherwise, use bottom." t)
(autoload 'which-key-setup-side-window-bottom "which-key" "\
Set up side-window that opens on bottom." t)
(autoload 'which-key-setup-minibuffer "which-key" "\
Set up minibuffer display.
Do not use this setup if you use the paging commands.  Instead use
`which-key-setup-side-window-bottom', which is nearly identical
but more functional." t)
(autoload 'which-key-add-keymap-based-replacements "which-key" "\
Replace the description of KEY using REPLACEMENT in KEYMAP.
KEY should take a format suitable for use in `kbd'. REPLACEMENT
should be a cons cell of the form (STRING . COMMAND) for each
REPLACEMENT, where STRING is the replacement string and COMMAND
is a symbol corresponding to the intended command to be
replaced. COMMAND can be nil if the binding corresponds to a key
prefix. An example is

(which-key-add-keymap-based-replacements global-map
  \"C-x w\" \\='(\"Save as\" . write-file)).

For backwards compatibility, REPLACEMENT can also be a string,
but the above format is preferred, and the option to use a string
for REPLACEMENT will eventually be removed.

(fn KEYMAP KEY REPLACEMENT &rest MORE)")
(function-put 'which-key-add-keymap-based-replacements 'lisp-indent-function 'defun)
(autoload 'which-key-add-key-based-replacements "which-key" "\
Replace the description of KEY-SEQUENCE with REPLACEMENT.
KEY-SEQUENCE is a string suitable for use in `kbd'. REPLACEMENT
may either be a string, as in

(which-key-add-key-based-replacements \"C-x 1\" \"maximize\")

a cons of two strings as in

(which-key-add-key-based-replacements \"C-x 8\"
                                        \\='(\"unicode\" . \"Unicode keys\"))

or a function that takes a (KEY . BINDING) cons and returns a
replacement.

In the second case, the second string is used to provide a longer
name for the keys under a prefix.

MORE allows you to specifcy additional KEY REPLACEMENT pairs.  All
replacements are added to `which-key-replacement-alist'.

(fn KEY-SEQUENCE REPLACEMENT &rest MORE)")
(autoload 'which-key-add-major-mode-key-based-replacements "which-key" "\
Functions like `which-key-add-key-based-replacements'.
The difference is that MODE specifies the `major-mode' that must
be active for KEY-SEQUENCE and REPLACEMENT (MORE contains
addition KEY-SEQUENCE REPLACEMENT pairs) to apply.

(fn MODE KEY-SEQUENCE REPLACEMENT &rest MORE)")
(function-put 'which-key-add-major-mode-key-based-replacements 'lisp-indent-function 'defun)
(autoload 'which-key-reload-key-sequence "which-key" "\
Simulate entering the key sequence KEY-SEQ.
KEY-SEQ should be a list of events as produced by
`listify-key-sequence'.  If nil, KEY-SEQ defaults to
`which-key--current-key-list'. Any prefix arguments that were
used are reapplied to the new key sequence.

(fn &optional KEY-SEQ)")
(autoload 'which-key-show-standard-help "which-key" "\
Call the command in `which-key--prefix-help-cmd-backup'.
Usually this is `describe-prefix-bindings'.

(fn &optional _)" t)
(autoload 'which-key-show-next-page-no-cycle "which-key" "\
Show next page of keys or `which-key-show-standard-help'." t)
(autoload 'which-key-show-previous-page-no-cycle "which-key" "\
Show previous page of keys if one exists." t)
(autoload 'which-key-show-next-page-cycle "which-key" "\
Show the next page of keys, cycling from end to beginning.

(fn &optional _)" t)
(autoload 'which-key-show-previous-page-cycle "which-key" "\
Show the previous page of keys, cycling from beginning to end.

(fn &optional _)" t)
(autoload 'which-key-show-top-level "which-key" "\
Show top-level bindings.

(fn &optional _)" t)
(autoload 'which-key-show-major-mode "which-key" "\
Show top-level bindings in the map of the current major mode.
This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. 

(fn &optional ALL)" t)
(autoload 'which-key-show-full-major-mode "which-key" "\
Show all bindings in the map of the current major mode.
This function will also detect evil bindings made using
`evil-define-key' in this map. These bindings will depend on the
current evil state. " t)
(autoload 'which-key-dump-bindings "which-key" "\
Dump bindings from PREFIX into buffer named BUFFER-NAME.
PREFIX should be a string suitable for `kbd'.

(fn PREFIX BUFFER-NAME)" t)
(autoload 'which-key-undo-key "which-key" "\
Undo last keypress and force which-key update.

(fn &optional _)" t)
(autoload 'which-key-C-h-dispatch "which-key" "\
Dispatch C-h commands by looking up key in `which-key-C-h-map'.
This command is always accessible (from any prefix) if
`which-key-use-C-h-commands' is non nil." t)
(autoload 'which-key-show-keymap "which-key" "\
Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

If NO-PAGING is non-nil, which-key will not intercept subsequent
keypresses for the paging functionality.

(fn KEYMAP &optional NO-PAGING)" t)
(autoload 'which-key-show-full-keymap "which-key" "\
Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively from all available keymaps.

(fn KEYMAP)" t)
(autoload 'which-key-show-minor-mode-keymap "which-key" "\
Show the top-level bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'.

(fn &optional ALL)" t)
(autoload 'which-key-show-full-minor-mode-keymap "which-key" "\
Show all bindings in KEYMAP using which-key.
KEYMAP is selected interactively by mode in
`minor-mode-map-alist'." t)
(register-definition-prefixes "which-key" '("evil-state" "which-key-"))


(provide 'which-key-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/compat-29.1.4.5/compat-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/compat-29.1.4.5/compat-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "compat" '("compat-"))



(register-definition-prefixes "compat-macs" '("compat-"))


(provide 'compat-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/vertico-20240511.2047/vertico-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/vertico-20240511.2047/vertico-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(defvar vertico-mode nil "\
Non-nil if Vertico mode is enabled.
See the `vertico-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-mode'.")
(custom-autoload 'vertico-mode "vertico" nil)
(autoload 'vertico-mode "vertico" "\
VERTical Interactive COmpletion.

This is a global minor mode.  If called interactively, toggle the
`Vertico mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico" '("vertico-"))



(defvar vertico-buffer-mode nil "\
Non-nil if Vertico-Buffer mode is enabled.
See the `vertico-buffer-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-buffer-mode'.")
(custom-autoload 'vertico-buffer-mode "vertico-buffer" nil)
(autoload 'vertico-buffer-mode "vertico-buffer" "\
Display Vertico like a regular buffer in a large window.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Buffer mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-buffer-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-buffer" '("vertico-buffer-"))



(autoload 'vertico-directory-enter "vertico-directory" "\
Enter directory or exit completion with current candidate.
Exit with current input if prefix ARG is given.

(fn &optional ARG)" t)
(autoload 'vertico-directory-up "vertico-directory" "\
Delete N names before point.

(fn &optional N)" t)
(autoload 'vertico-directory-delete-char "vertico-directory" "\
Delete N directories or chars before point.

(fn &optional N)" t)
(autoload 'vertico-directory-delete-word "vertico-directory" "\
Delete N directories or words before point.

(fn &optional N)" t)
(autoload 'vertico-directory-tidy "vertico-directory" "\
Tidy shadowed file name, see `rfn-eshadow-overlay'.")



(defvar vertico-flat-mode nil "\
Non-nil if Vertico-Flat mode is enabled.
See the `vertico-flat-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-flat-mode'.")
(custom-autoload 'vertico-flat-mode "vertico-flat" nil)
(autoload 'vertico-flat-mode "vertico-flat" "\
Flat, horizontal display for Vertico.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Flat mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-flat-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-flat" '("vertico-flat-"))



(defvar vertico-grid-mode nil "\
Non-nil if Vertico-Grid mode is enabled.
See the `vertico-grid-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-grid-mode'.")
(custom-autoload 'vertico-grid-mode "vertico-grid" nil)
(autoload 'vertico-grid-mode "vertico-grid" "\
Grid display for Vertico.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Grid mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-grid-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-grid" '("vertico-grid-"))



(defvar vertico-indexed-mode nil "\
Non-nil if Vertico-Indexed mode is enabled.
See the `vertico-indexed-mode' command
for a description of this minor mode.")
(custom-autoload 'vertico-indexed-mode "vertico-indexed" nil)
(autoload 'vertico-indexed-mode "vertico-indexed" "\
Prefix candidates with indices.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Indexed mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-indexed-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-indexed" '("vertico-indexed-"))



(defvar vertico-mouse-mode nil "\
Non-nil if Vertico-Mouse mode is enabled.
See the `vertico-mouse-mode' command
for a description of this minor mode.")
(custom-autoload 'vertico-mouse-mode "vertico-mouse" nil)
(autoload 'vertico-mouse-mode "vertico-mouse" "\
Mouse support for Vertico.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Mouse mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-mouse-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-mouse" '("vertico-mouse-"))



(defvar vertico-multiform-mode nil "\
Non-nil if Vertico-Multiform mode is enabled.
See the `vertico-multiform-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-multiform-mode'.")
(custom-autoload 'vertico-multiform-mode "vertico-multiform" nil)
(autoload 'vertico-multiform-mode "vertico-multiform" "\
Configure Vertico in various forms per command.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Multiform mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-multiform-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-multiform" '("vertico-multiform-"))



(autoload 'vertico-quick-jump "vertico-quick" "\
Jump to candidate using quick keys." t)
(autoload 'vertico-quick-exit "vertico-quick" "\
Exit with candidate using quick keys." t)
(autoload 'vertico-quick-insert "vertico-quick" "\
Insert candidate using quick keys." t)
(register-definition-prefixes "vertico-quick" '("vertico-quick"))



(autoload 'vertico-repeat-save "vertico-repeat" "\
Save Vertico session for `vertico-repeat'.
This function must be registered as `minibuffer-setup-hook'.")
(autoload 'vertico-repeat-next "vertico-repeat" "\
Repeat Nth next Vertico completion session.
This command must be called from an existing Vertico session
after `vertico-repeat-previous'.

(fn N)" t)
(autoload 'vertico-repeat-previous "vertico-repeat" "\
Repeat Nth previous Vertico completion session.
If called from an existing Vertico session, restore the input and
selected candidate for the current command.

(fn N)" t)
(autoload 'vertico-repeat-select "vertico-repeat" "\
Select a Vertico session from the session history and repeat it.
If called from an existing Vertico session, you can select among
previous sessions for the current command." t)
(autoload 'vertico-repeat "vertico-repeat" "\
Repeat last Vertico session.
If prefix ARG is non-nil, offer completion menu to select from session history.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-repeat" '("vertico-repeat-"))



(defvar vertico-reverse-mode nil "\
Non-nil if Vertico-Reverse mode is enabled.
See the `vertico-reverse-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-reverse-mode'.")
(custom-autoload 'vertico-reverse-mode "vertico-reverse" nil)
(autoload 'vertico-reverse-mode "vertico-reverse" "\
Reverse the Vertico display.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Reverse mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-reverse-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-reverse" '("vertico-reverse-map"))



(autoload 'vertico-suspend "vertico-suspend" "\
Suspend the current completion session.
If the command is invoked from within the Vertico minibuffer, the
current session is suspended.  If the command is invoked from
outside the minibuffer, the active minibuffer is either selected
or the latest completion session is restored." t)
(register-definition-prefixes "vertico-suspend" '("vertico-suspend--"))



(defvar vertico-unobtrusive-mode nil "\
Non-nil if Vertico-Unobtrusive mode is enabled.
See the `vertico-unobtrusive-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-unobtrusive-mode'.")
(custom-autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" nil)
(autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" "\
Unobtrusive display for Vertico.

This is a global minor mode.  If called interactively, toggle the
`Vertico-Unobtrusive mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='vertico-unobtrusive-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "vertico-unobtrusive" '("vertico-unobtrusive--restore"))


(provide 'vertico-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/ivy-20240519.1636/ivy-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/ivy-20240519.1636/ivy-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "colir" '("colir-"))



(autoload 'ivy-resume "ivy" "\
Resume the last completion session, or SESSION if non-nil.
With a prefix arg, try to restore a recorded completion session,
if one exists.

(fn &optional SESSION)" t)
(autoload 'ivy-read "ivy" "\
Read a string in the minibuffer, with completion.

PROMPT is a string, normally ending in a colon and a space.
`ivy-count-format' is prepended to PROMPT during completion.

COLLECTION is either a list of strings, a function, an alist, or
a hash table, supplied for `minibuffer-completion-table'.

PREDICATE is applied to filter out the COLLECTION immediately.
This argument is for compatibility with `completing-read'.

When REQUIRE-MATCH is non-nil, only members of COLLECTION can be
selected. In can also be a lambda.

If INITIAL-INPUT is non-nil, then insert that input in the
minibuffer initially.

HISTORY is a name of a variable to hold the completion session
history.

KEYMAP is composed with `ivy-minibuffer-map'.

PRESELECT, when non-nil, determines which one of the candidates
matching INITIAL-INPUT to select initially.  An integer stands
for the position of the desired candidate in the collection,
counting from zero.  Otherwise, use the first occurrence of
PRESELECT in the collection.  Comparison is first done with
`equal'.  If that fails, and when applicable, match PRESELECT as
a regular expression.

DEF is for compatibility with `completing-read'.

UPDATE-FN is called each time the candidate list is re-displayed.

When SORT is non-nil, `ivy-sort-functions-alist' determines how
to sort candidates before displaying them.

ACTION is a function to call after selecting a candidate.
It takes one argument, the selected candidate. If COLLECTION is
an alist, the argument is a cons cell, otherwise it's a string.

MULTI-ACTION, when non-nil, is called instead of ACTION when
there are marked candidates. It takes the list of candidates as
its only argument. When it's nil, ACTION is called on each marked
candidate.

UNWIND is a function of no arguments to call before exiting.

RE-BUILDER is a function transforming input text into a regex
pattern.

MATCHER is a function which can override how candidates are
filtered based on user input.  It takes a regex pattern and a
list of candidates, and returns the list of matching candidates.

DYNAMIC-COLLECTION is a boolean specifying whether the list of
candidates is updated after each input by calling COLLECTION.

EXTRA-PROPS is a plist that can be used to store
collection-specific session-specific data.

CALLER is a symbol to uniquely identify the caller to `ivy-read'.
It is used, along with COLLECTION, to determine which
customizations apply to the current completion session.

(fn PROMPT COLLECTION &key PREDICATE REQUIRE-MATCH INITIAL-INPUT HISTORY PRESELECT DEF KEYMAP UPDATE-FN SORT ACTION MULTI-ACTION UNWIND RE-BUILDER MATCHER DYNAMIC-COLLECTION EXTRA-PROPS CALLER)")
(autoload 'ivy-completing-read "ivy" "\
Read a string in the minibuffer, with completion.

This interface conforms to `completing-read' and can be used for
`completing-read-function'.

PROMPT is a string that normally ends in a colon and a space.
COLLECTION is either a list of strings, an alist, an obarray, or a hash table.
PREDICATE limits completion to a subset of COLLECTION.
REQUIRE-MATCH is a boolean value or a symbol.  See `completing-read'.
INITIAL-INPUT is a string inserted into the minibuffer initially.
HISTORY is a list of previously selected inputs.
DEF is the default value.
INHERIT-INPUT-METHOD is currently ignored.

(fn PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HISTORY DEF INHERIT-INPUT-METHOD)")
(defvar ivy-mode nil "\
Non-nil if ivy mode is enabled.
See the `ivy-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ivy-mode'.")
(custom-autoload 'ivy-mode "ivy" nil)
(autoload 'ivy-mode "ivy" "\
Toggle Ivy mode on or off.
Turn Ivy mode on if ARG is positive, off otherwise.
Turning on Ivy mode sets `completing-read-function' to
`ivy-completing-read'.

Global bindings:
\\{ivy-mode-map}

Minibuffer bindings:
\\{ivy-minibuffer-map}

(fn &optional ARG)" t)
(autoload 'ivy-switch-buffer "ivy" "\
Switch to another buffer." t)
(autoload 'ivy-switch-view "ivy" "\
Switch to one of the window views stored by `ivy-push-view'." t)
(autoload 'ivy-switch-buffer-other-window "ivy" "\
Switch to another buffer in another window." t)
(register-definition-prefixes "ivy" '("ivy-" "with-ivy-window"))



(register-definition-prefixes "ivy-overlay" '("ivy-"))


(provide 'ivy-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/swiper-20240520.1202/swiper-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/swiper-20240520.1202/swiper-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'swiper-avy "swiper" "\
Jump to one of the current swiper candidates with `avy'." t)
(autoload 'swiper-backward "swiper" "\
`isearch-backward' with an overview.
When non-nil, INITIAL-INPUT is the initial search pattern.

(fn &optional INITIAL-INPUT)" t)
(autoload 'swiper-thing-at-point "swiper" "\
`swiper' with `ivy-thing-at-point'." t)
(autoload 'swiper-all-thing-at-point "swiper" "\
`swiper-all' with `ivy-thing-at-point'." t)
(autoload 'swiper "swiper" "\
`isearch-forward' with an overview.
When non-nil, INITIAL-INPUT is the initial search pattern.

(fn &optional INITIAL-INPUT)" t)
(autoload 'swiper-all "swiper" "\
Run `swiper' for all open buffers.

(fn &optional INITIAL-INPUT)" t)
(autoload 'swiper-isearch "swiper" "\
A `swiper' that's not line-based.

(fn &optional INITIAL-INPUT)" t)
(autoload 'swiper-isearch-backward "swiper" "\
Like `swiper-isearch' but the first result is before the point.

(fn &optional INITIAL-INPUT)" t)
(register-definition-prefixes "swiper" '("swiper-"))


(provide 'swiper-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/s-20220902.1511/s-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/s-20220902.1511/s-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "s" '("s-"))


(provide 's-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/dash-20240510.1327/dash-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/dash-20240510.1327/dash-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'dash-fontify-mode "dash" "\
Toggle fontification of Dash special variables.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'.

This is a minor mode.  If called interactively, toggle the
`Dash-Fontify mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `dash-fontify-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(put 'global-dash-fontify-mode 'globalized-minor-mode t)
(defvar global-dash-fontify-mode nil "\
Non-nil if Global Dash-Fontify mode is enabled.
See the `global-dash-fontify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-dash-fontify-mode'.")
(custom-autoload 'global-dash-fontify-mode "dash" nil)
(autoload 'global-dash-fontify-mode "dash" "\
Toggle Dash-Fontify mode in all buffers.
With prefix ARG, enable Global Dash-Fontify mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Dash-Fontify mode is enabled in all buffers where
`dash--turn-on-fontify-mode' would do it.

See `dash-fontify-mode' for more information on Dash-Fontify mode.

(fn &optional ARG)" t)
(autoload 'dash-register-info-lookup "dash" "\
Register the Dash Info manual with `info-lookup-symbol'.
This allows Dash symbols to be looked up with \\[info-lookup-symbol]." t)
(register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-juxt" "-keep" "-l" "-m" "-no" "-o" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-"))


(provide 'dash-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/f-20240308.906/f-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/f-20240308.906/f-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "f" '("f-"))


(provide 'f-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/shrink-path-20190208.1335/shrink-path-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/shrink-path-20190208.1335/shrink-path-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "shrink-path" '("shrink-path-"))


(provide 'shrink-path-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/rainbow-mode-1.0.6/rainbow-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/rainbow-mode-1.0.6/rainbow-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'rainbow-mode "rainbow-mode" "\
Colorize strings that represent colors.

This will fontify with colors the string like \"#aabbcc\" or \"blue\".

This is a minor mode.  If called interactively, toggle the
`Rainbow mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `rainbow-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "rainbow-mode" '("rainbow-"))


(provide 'rainbow-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/php-mode-20240118.1458/php-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/php-mode-20240118.1458/php-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(let ((loads (get 'php 'custom-loads))) (if (member '"php" loads) nil (put 'php 'custom-loads (cons '"php" loads)) (put 'languages 'custom-loads (cons 'php (get 'languages 'custom-loads)))))
(autoload 'php-base-mode "php" "\
Generic major mode for editing PHP.

This mode is intended to be inherited by concrete major modes.
Currently there are `php-mode' and `php-ts-mode'.

(fn)" t)
(autoload 'php-mode-maybe "php" "\
Select PHP mode or other major mode." t)
(autoload 'php-current-class "php" "\
Insert current class name if cursor in class context." t)
(autoload 'php-current-namespace "php" "\
Insert current namespace if cursor in namespace context." t)
(autoload 'php-copyit-fqsen "php" "\
Copy/kill class/method FQSEN." t)
(autoload 'php-run-builtin-web-server "php" "\
Run PHP Built-in web server.

`ROUTER-OR-DIR': Path to router PHP script or Document root.
`HOSTNAME': Hostname or IP address of Built-in web server.
`PORT': Port number of Built-in web server.
`DOCUMENT-ROOT': Path to Document root.

When `DOCUMENT-ROOT' is NIL, the document root is obtained from `ROUTER-OR-DIR'.

(fn ROUTER-OR-DIR HOSTNAME PORT &optional DOCUMENT-ROOT)" t)
(autoload 'php-find-system-php-ini-file "php" "\
Find php.ini FILE by `php --ini'.

(fn &optional FILE)" t)
(register-definition-prefixes "php" '("php-"))



(autoload 'php-align-setup "php-align" "\
Setup alignment configuration for PHP code.")
(autoload 'php-align-mode "php-align" "\
Alignment lines for PHP script.

This is a minor mode.  If called interactively, toggle the
`Php-Align mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `php-align-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "php-align" '("php-align-"))



(let ((loads (get 'php-complete 'custom-loads))) (if (member '"php-complete" loads) nil (put 'php-complete 'custom-loads (cons '"php-complete" loads)) (put 'php-mode 'custom-loads (cons 'php-complete (get 'php-mode 'custom-loads)))))
(defvar php-complete-function-modules '(bcmath core gmp libxml intl mbstring pcntl posix sodium xml xmlwriter) "\
Module names for function names completion.")
(custom-autoload 'php-complete-function-modules "php-complete" t)
(put 'php-complete-function-modules 'safe-local-variable (lambda (value) (and (listp value) (cl-loop for v in values always (assq v php-defs-functions-alist)))))
(autoload 'php-complete-complete-function "php-complete" "\
Complete PHP keyword at point.

If INTERACTIVE is nil the function acts like a capf.

(fn &optional INTERACTIVE)" t)
(register-definition-prefixes "php-complete" '("php-complete--"))



(register-definition-prefixes "php-defs" '("php-defs-functions-alist"))



(let ((loads (get 'php-faces 'custom-loads))) (if (member '"php-face" loads) nil (put 'php-faces 'custom-loads (cons '"php-face" loads)) (put 'php-mode 'custom-loads (cons 'php-faces (get 'php-mode 'custom-loads)))))
(register-definition-prefixes "php-face" '("php-annotations-annotation-face"))



(autoload 'php-flymake "php-flymake" "\
Flymake backend for PHP syntax check.

See `flymake-diagnostic-functions' about REPORT-FN and ARGS parameters.

(fn REPORT-FN &rest ARGS)")
(register-definition-prefixes "php-flymake" '("php-flymake-"))



(autoload 'php-format-this-buffer-file "php-format" "\
Apply format this buffer file." t)
(autoload 'php-format-project "php-format" "\
Apply format this buffer file." t)
(autoload 'php-format-on-after-save-hook "php-format" "\
Apply format on after save hook.")
(autoload 'php-format-auto-mode "php-format" "\
Automatically apply formatting when saving an edited file.

This is a minor mode.  If called interactively, toggle the
`Php-Format-Auto mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `php-format-auto-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "php-format" '("php-format-"))



(defvar php-ide-features nil "\
A set of PHP-IDE features symbol.")
(custom-autoload 'php-ide-features "php-ide" t)
(put 'php-ide-features 'safe-local-variable (lambda (v) (cl-loop for feature in (if (listp v) v (list v)) always (symbolp feature))))
(defvar php-ide-eglot-executable nil "\
Command name or path to the command of Eglot LSP executable.")
(custom-autoload 'php-ide-eglot-executable "php-ide" t)
(put 'php-ide-eglot-executable 'safe-local-variable (lambda (v) (cond ((stringp v) (file-exists-p v)) ((listp v) (cl-every #'stringp v)) ((assq v php-ide-lsp-command-alist)))))
(autoload 'php-ide-eglot-server-program "php-ide" "\
Return a list of command to execute LSP Server.")
(defvar php-ide-mode-functions nil "\
Hook functions called when before activating or deactivating PHP-IDE.
Notice that two arguments (FEATURE ACTIVATE) are given.

FEATURE: A symbol, like \\='lsp-mode.
ACTIVATE: T is given when activeting, NIL when deactivating PHP-IDE.")
(custom-autoload 'php-ide-mode-functions "php-ide" t)
(put 'php-ide-mode-functions 'safe-local-variable (lambda (functions) (and (listp functions) (cl-every #'functionp functions))))
(autoload 'php-ide-mode "php-ide" "\
Minor mode for integrate IDE-like tools.

This is a minor mode.  If called interactively, toggle the
`Php-Ide mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `php-ide-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'php-ide-turn-on "php-ide" "\
Turn on PHP IDE-FEATURES and execute `php-ide-mode'.")
(register-definition-prefixes "php-ide" '("php-ide-"))



(autoload 'php-ide-phpactor-activate "php-ide-phpactor" "\
Activate PHP-IDE using phpactor.el." t)
(autoload 'php-ide-phpactor-deactivate "php-ide-phpactor" "\
Dectivate PHP-IDE using phpactor.el." t)
(register-definition-prefixes "php-ide-phpactor" '("php-ide-phpactor-"))



(autoload 'php-local-manual-search "php-local-manual" "\
Search the local PHP documentation (i.e. in `php-manual-path') for
the word at point.  The function returns t if the requested documentation
exists, and nil otherwise.

With a prefix argument, prompt (with completion) for a word to search for.

(fn WORD)" t)
(define-obsolete-function-alias 'php-search-local-documentation #'php-local-manual-search "2.0.0")
(register-definition-prefixes "php-local-manual" '("php-local-manual-"))



(let ((loads (get 'php-mode 'custom-loads))) (if (member '"php-mode" loads) nil (put 'php-mode 'custom-loads (cons '"php-mode" loads)) (put 'languages 'custom-loads (cons 'php-mode (get 'languages 'custom-loads)))))
(add-to-list 'interpreter-mode-alist (cons "php\\(?:-?[34578]\\(?:\\.[0-9]+\\)*\\)?" 'php-mode))
(define-obsolete-variable-alias 'php-available-project-root-files 'php-project-available-root-files "\
1.19.0")
(autoload 'php-mode "php-mode" "\
Major mode for editing PHP code.

\\{php-mode-map}

(fn)" t)
(add-to-list 'auto-mode-alist '("/\\.php_cs\\(?:\\.dist\\)?\\'" . php-mode))
(add-to-list 'auto-mode-alist '("\\.\\(?:php\\.inc\\|stub\\)\\'" . php-mode))
(add-to-list 'auto-mode-alist '("\\.\\(?:php[s345]?\\|phtml\\)\\'" . php-mode-maybe))
(register-definition-prefixes "php-mode" '("php-"))



(register-definition-prefixes "php-mode-debug" '("php-mode-debug"))



(defvar-local php-project-root 'auto "\
Method of searching for the top level directory.

`auto' (default)
      Try to search file in order of `php-project-available-root-files'.

SYMBOL
      Key of `php-project-available-root-files'.

STRING
      A file/directory name of top level marker.
      If the string is an actual directory path, it is set as the absolute path
      of the root directory, not the marker.")
(put 'php-project-root 'safe-local-variable #'(lambda (v) (or (stringp v) (assq v php-project-available-root-files))))
(defvar-local php-project-etags-file nil)
(put 'php-project-etags-file 'safe-local-variable #'(lambda (v) (or (functionp v) (eq v t) (php-project--eval-bootstrap-scripts v))))
(defvar-local php-project-bootstrap-scripts nil "\
List of path to bootstrap php script file.

The ideal bootstrap file is silent, it only includes dependent files,
defines constants, and sets the class loaders.")
(put 'php-project-bootstrap-scripts 'safe-local-variable #'php-project--eval-bootstrap-scripts)
(defvar-local php-project-php-executable nil "\
Path to php executable file.")
(put 'php-project-php-executable 'safe-local-variable #'(lambda (v) (and (stringp v) (file-executable-p v))))
(defvar-local php-project-coding-style nil "\
Symbol value of the coding style of the project that PHP major mode refers to.

Typically it is `pear', `drupal', `wordpress', `symfony2' and `psr2'.")
(put 'php-project-coding-style 'safe-local-variable #'symbolp)
(defvar-local php-project-align-lines t "\
If T, automatically turn on `php-align-mode' by `php-align-setup'.")
(put 'php-project-align-lines 'safe-local-variable #'booleanp)
(defvar-local php-project-php-file-as-template 'auto "\

`auto' (default)
      Automatically switch to mode for template when HTML tag detected in file.

`t'
      Switch all PHP files in that directory to mode for HTML template.

`nil'
      Any .php  in that directory is just a PHP script.

((PATTERN . SYMBOL))
      Alist of file name pattern regular expressions and the above symbol pairs.
      PATTERN is regexp pattern.
")
(put 'php-project-php-file-as-template 'safe-local-variable #'php-project--validate-php-file-as-template)
(defvar-local php-project-repl nil "\
Function name or path to REPL (interactive shell) script.")
(put 'php-project-repl 'safe-local-variable #'(lambda (v) (or (functionp v) (php-project--eval-bootstrap-scripts v))))
(defvar-local php-project-unit-test nil "\
Function name or path to unit test script.")
(put 'php-project-unit-test 'safe-local-variable #'(lambda (v) (or (functionp v) (php-project--eval-bootstrap-scripts v))))
(defvar-local php-project-deploy nil "\
Function name or path to deploy script.")
(put 'php-project-deploy 'safe-local-variable #'(lambda (v) (or (functionp v) (php-project--eval-bootstrap-scripts v))))
(defvar-local php-project-build nil "\
Function name or path to build script.")
(put 'php-project-build 'safe-local-variable #'(lambda (v) (or (functionp v) (php-project--eval-bootstrap-scripts v))))
(defvar-local php-project-server-start nil "\
Function name or path to server-start script.")
(put 'php-project-server-start 'safe-local-variable #'(lambda (v) (or (functionp v) (php-project--eval-bootstrap-scripts v))))
(autoload 'php-project-get-bootstrap-scripts "php-project" "\
Return list of bootstrap script.")
(autoload 'php-project-get-root-dir "php-project" "\
Return path to current PHP project.")
(autoload 'php-project-project-find-function "php-project" "\
Return path to current PHP project from DIR.

This function is compatible with `project-find-functions'.

(fn DIR)")
(register-definition-prefixes "php-project" '("php-project-"))


(provide 'php-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/org-modern-20240515.500/org-modern-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/org-modern-20240515.500/org-modern-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'org-modern-mode "org-modern" "\
Modern looks for Org.

This is a minor mode.  If called interactively, toggle the
`Org-Modern mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `org-modern-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'org-modern-agenda "org-modern" "\
Finalize Org agenda highlighting.")
(put 'global-org-modern-mode 'globalized-minor-mode t)
(defvar global-org-modern-mode nil "\
Non-nil if Global Org-Modern mode is enabled.
See the `global-org-modern-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-org-modern-mode'.")
(custom-autoload 'global-org-modern-mode "org-modern" nil)
(autoload 'global-org-modern-mode "org-modern" "\
Toggle Org-Modern mode in all buffers.
With prefix ARG, enable Global Org-Modern mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Org-Modern mode is enabled in all buffers where `org-modern--on' would
do it.

See `org-modern-mode' for more information on Org-Modern mode.

(fn &optional ARG)" t)
(register-definition-prefixes "org-modern" '("org-modern-"))


(provide 'org-modern-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/async-20240323.1912/async-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/async-20240323.1912/async-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'async-start-process "async" "\
Start the executable PROGRAM asynchronously named NAME.  See `async-start'.
PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the
process object when done.  If FINISH-FUNC is nil, the future
object will return the process object when the program is
finished.  Set DEFAULT-DIRECTORY to change PROGRAM's current
working directory.

(fn NAME PROGRAM FINISH-FUNC &rest PROGRAM-ARGS)")
(autoload 'async-start "async" "\
Execute START-FUNC (often a lambda) in a subordinate Emacs process.
When done, the return value is passed to FINISH-FUNC.  Example:

    (async-start
       ;; What to do in the child process
       (lambda ()
         (message \"This is a test\")
         (sleep-for 3)
         222)

       ;; What to do when it finishes
       (lambda (result)
         (message \"Async process done, result should be 222: %s\"
                  result)))

If you call `async-send' from a child process, the message will
be also passed to the FINISH-FUNC.  You can test RESULT to see if
it is a message by using `async-message-p'.  If nil, it means
this is the final result.  Example of the FINISH-FUNC:

    (lambda (result)
      (if (async-message-p result)
          (message \"Received a message from child process: %s\" result)
        (message \"Async process done, result: %s\" result)))

If FINISH-FUNC is nil or missing, a future is returned that can
be inspected using `async-get', blocking until the value is
ready.  Example:

    (let ((proc (async-start
                   ;; What to do in the child process
                   (lambda ()
                     (message \"This is a test\")
                     (sleep-for 3)
                     222))))

        (message \"I'm going to do some work here\") ;; ....

        (message \"Waiting on async process, result should be 222: %s\"
                 (async-get proc)))

If you don't want to use a callback, and you don't care about any
return value from the child process, pass the `ignore' symbol as
the second argument (if you don't, and never call `async-get', it
will leave *emacs* process buffers hanging around):

    (async-start
     (lambda ()
       (delete-file \"a remote file on a slow link\" nil))
     \\='ignore)

Special case:
If the output of START-FUNC is a string with properties
e.g. (buffer-string) RESULT will be transformed in a list where the
car is the string itself (without props) and the cdr the rest of
properties, this allows using in FINISH-FUNC the string without
properties and then apply the properties in cdr to this string (if
needed).
Properties handling special objects like markers are returned as
list to allow restoring them later.
See <https://github.com/jwiegley/emacs-async/issues/145> for more infos.

Note: Even when FINISH-FUNC is present, a future is still
returned except that it yields no value (since the value is
passed to FINISH-FUNC).  Call `async-get' on such a future always
returns nil.  It can still be useful, however, as an argument to
`async-ready' or `async-wait'.

(fn START-FUNC &optional FINISH-FUNC)")
(register-definition-prefixes "async" '("async-"))



(autoload 'async-byte-recompile-directory "async-bytecomp" "\
Compile all *.el files in DIRECTORY asynchronously.
All *.elc files are systematically deleted before proceeding.

(fn DIRECTORY &optional QUIET)")
(defvar async-bytecomp-package-mode nil "\
Non-nil if Async-Bytecomp-Package mode is enabled.
See the `async-bytecomp-package-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `async-bytecomp-package-mode'.")
(custom-autoload 'async-bytecomp-package-mode "async-bytecomp" nil)
(autoload 'async-bytecomp-package-mode "async-bytecomp" "\
Byte compile asynchronously packages installed with package.el.

Async compilation of packages can be controlled by
`async-bytecomp-allowed-packages'.

This is a global minor mode.  If called interactively, toggle the
`Async-Bytecomp-Package mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='async-bytecomp-package-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'async-byte-compile-file "async-bytecomp" "\
Byte compile Lisp code FILE asynchronously.

Same as `byte-compile-file' but asynchronous.

(fn FILE)" t)
(register-definition-prefixes "async-bytecomp" '("async-"))



(defvar dired-async-mode nil "\
Non-nil if Dired-Async mode is enabled.
See the `dired-async-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `dired-async-mode'.")
(custom-autoload 'dired-async-mode "dired-async" nil)
(autoload 'dired-async-mode "dired-async" "\
Do dired actions asynchronously.

This is a global minor mode.  If called interactively, toggle the
`Dired-Async mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='dired-async-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'dired-async-do-copy "dired-async" "\
Run ‘dired-do-copy’ asynchronously.

(fn &optional ARG)" t)
(autoload 'dired-async-do-symlink "dired-async" "\
Run ‘dired-do-symlink’ asynchronously.

(fn &optional ARG)" t)
(autoload 'dired-async-do-hardlink "dired-async" "\
Run ‘dired-do-hardlink’ asynchronously.

(fn &optional ARG)" t)
(autoload 'dired-async-do-rename "dired-async" "\
Run ‘dired-do-rename’ asynchronously.

(fn &optional ARG)" t)
(register-definition-prefixes "dired-async" '("dired-async-"))



(register-definition-prefixes "smtpmail-async" '("async-smtpmail-"))


(provide 'async-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/org-download-20220906.1929/org-download-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/org-download-20220906.1929/org-download-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'org-download-enable "org-download" "\
Enable org-download.")
(register-definition-prefixes "org-download" '("org-download-"))


(provide 'org-download-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/org-bullets-20200317.1740/org-bullets-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/org-bullets-20200317.1740/org-bullets-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'org-bullets-mode "org-bullets" "\
Use UTF8 bullets in Org mode headings.

This is a minor mode.  If called interactively, toggle the
`Org-Bullets mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `org-bullets-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "org-bullets" '("org-bullets-"))


(provide 'org-bullets-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/nerd-icons-20240524.311/nerd-icons-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/nerd-icons-20240524.311/nerd-icons-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'nerd-icons-install-fonts "nerd-icons" "\
Helper function to download and install the latests fonts based on OS.
The provided Nerd Font is Symbols Nerd Font Mono.
When PFX is non-nil, ignore the prompt and just install

(fn &optional PFX)" t)
(autoload 'nerd-icons-insert "nerd-icons" "\
Interactive icon insertion function.
When Prefix ARG is non-nil, insert the propertized icon.
When GLYPH-SET is non-nil, limit the candidates to the icon set matching it.

(fn &optional ARG GLYPH-SET)" t)
(autoload 'nerd-icons-icon-for-dir "nerd-icons" "\
Get the formatted icon for DIR.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn DIR &rest ARG-OVERRIDES)")
(autoload 'nerd-icons-icon-for-file "nerd-icons" "\
Get the formatted icon for FILE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn FILE &rest ARG-OVERRIDES)")
(autoload 'nerd-icons-icon-for-extension "nerd-icons" "\
Get the formatted icon for EXT.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn EXT &rest ARG-OVERRIDES)")
(autoload 'nerd-icons-icon-for-mode "nerd-icons" "\
Get the formatted icon for MODE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn MODE &rest ARG-OVERRIDES)")
(autoload 'nerd-icons-icon-for-url "nerd-icons" "\
Get the formatted icon for URL.
If an icon for URL isn't found in `nerd-icons-url-alist', a globe is used.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn URL &rest ARG-OVERRIDES)")
(autoload 'nerd-icons-icon-for-buffer "nerd-icons" "\
Get the formatted icon for the current buffer.

This function prioritises the use of the buffers file extension to
discern the icon when its `major-mode' matches its auto mode,
otherwise it will use the buffers `major-mode' to decide its
icon.")
(register-definition-prefixes "nerd-icons" '("nerd-icons-"))


(provide 'nerd-icons-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/neotree-20230815.219/neotree-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/neotree-20230815.219/neotree-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'neotree-find "neotree" "\
Quick select node which specified PATH in NeoTree.
If path is nil and no buffer file name, then use DEFAULT-PATH,

(fn &optional PATH DEFAULT-PATH)" t)
(autoload 'neotree-projectile-action "neotree" "\
Integration with `Projectile'.

Usage:
    (setq projectile-switch-project-action 'neotree-projectile-action).

When running `projectile-switch-project' (C-c p p), `neotree' will change root
automatically." t)
(autoload 'neotree-toggle "neotree" "\
Toggle show the NeoTree window." t)
(autoload 'neotree-show "neotree" "\
Show the NeoTree window." t)
(autoload 'neotree-hide "neotree" "\
Close the NeoTree window." t)
(autoload 'neotree-dir "neotree" "\
Show the NeoTree window, and change root to PATH.

(fn PATH)" t)
(defalias 'neotree 'neotree-show "\
Show the NeoTree window.")
(register-definition-prefixes "neotree" '("neo" "off-p"))


(provide 'neotree-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/lua-mode-20231023.947/lua-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/lua-mode-20231023.947/lua-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'lua-mode "lua-mode" "\
Major mode for editing Lua code.

(fn)" t)
(add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-mode))
(add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
(defalias 'run-lua #'lua-start-process)
(autoload 'lua-start-process "lua-mode" "\
Start a Lua process named NAME, running PROGRAM.
PROGRAM defaults to NAME, which defaults to `lua-default-application'.
When called interactively, switch to the process buffer.

(fn &optional NAME PROGRAM STARTFILE &rest SWITCHES)" t)
(register-definition-prefixes "lua-mode" '("lua-"))


(provide 'lua-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/js2-mode-20240418.6/js2-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/js2-mode-20240418.6/js2-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'js2-imenu-extras-setup "js2-imenu-extras")
(autoload 'js2-imenu-extras-mode "js2-imenu-extras" "\
Toggle Imenu support for frameworks and structural patterns.

This is a minor mode.  If called interactively, toggle the
`Js2-Imenu-Extras mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `js2-imenu-extras-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "js2-imenu-extras" '("js2-imenu-"))



(autoload 'js2-highlight-unused-variables-mode "js2-mode" "\
Toggle highlight of unused variables.

This is a minor mode.  If called interactively, toggle the
`Js2-Highlight-Unused-Variables mode' mode.  If the prefix
argument is positive, enable the mode, and if it is zero or
negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `js2-highlight-unused-variables-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'js2-minor-mode "js2-mode" "\
Minor mode for running js2 as a background linter.

This allows you to use a different major mode for JavaScript editing,
such as `js-mode', while retaining the asynchronous error/warning
highlighting features of `js2-mode'.

This is a minor mode.  If called interactively, toggle the `Js2
minor mode' mode.  If the prefix argument is positive, enable the
mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `js2-minor-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'js2-mode "js2-mode" "\
Major mode for editing JavaScript code.

(fn)" t)
(autoload 'js2-jsx-mode "js2-mode" "\
Major mode for editing JSX code in Emacs 26 and earlier.

To edit JSX code in Emacs 27, use `js-mode' as your major mode
with `js2-minor-mode' enabled.

To customize the indentation for this mode, set the SGML offset
variables (`sgml-basic-offset' et al) locally, like so:

  (defun set-jsx-indentation ()
    (setq-local sgml-basic-offset js2-basic-offset))
  (add-hook \\='js2-jsx-mode-hook #\\='set-jsx-indentation)

(fn)" t)
(register-definition-prefixes "js2-mode" '("js2-"))



(register-definition-prefixes "js2-old-indent" '("js2-"))


(provide 'js2-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/ivy-rich-20230425.1422/ivy-rich-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/ivy-rich-20230425.1422/ivy-rich-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(defvar ivy-rich-mode nil "\
Non-nil if Ivy-Rich mode is enabled.
See the `ivy-rich-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ivy-rich-mode'.")
(custom-autoload 'ivy-rich-mode "ivy-rich" nil)
(autoload 'ivy-rich-mode "ivy-rich" "\
Toggle ivy-rich mode globally.

This is a global minor mode.  If called interactively, toggle the
`Ivy-Rich mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='ivy-rich-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'ivy-rich-reload "ivy-rich")
(defvar ivy-rich-project-root-cache-mode nil "\
Non-nil if Ivy-Rich-Project-Root-Cache mode is enabled.
See the `ivy-rich-project-root-cache-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `ivy-rich-project-root-cache-mode'.")
(custom-autoload 'ivy-rich-project-root-cache-mode "ivy-rich" nil)
(autoload 'ivy-rich-project-root-cache-mode "ivy-rich" "\
Toggle ivy-rich-root-cache-mode globally.

This is a global minor mode.  If called interactively, toggle the
`Ivy-Rich-Project-Root-Cache mode' mode.  If the prefix argument
is positive, enable the mode, and if it is zero or negative,
disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='ivy-rich-project-root-cache-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "ivy-rich" '("ivy-rich-"))


(provide 'ivy-rich-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/htmlize-20240422.1351/htmlize-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/htmlize-20240422.1351/htmlize-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'htmlize-buffer "htmlize" "\
Convert BUFFER to HTML, preserving colors and decorations.

The generated HTML is available in a new buffer, which is returned.
When invoked interactively (or if optional INTERACTIVE is non-nil),
the new buffer is selected in the current window.  The title of the
generated document will be set to the buffer's file name or, if that
is not available, to the buffer's name.

Note that htmlize doesn't fontify your buffers, it only uses the
decorations that are already present.  If you don't set up font-lock or
something else to fontify your buffers, the resulting HTML will be
plain.  Likewise, if you don't like the choice of colors, fix the mode
that created them, or simply alter the faces it uses.

(fn &optional BUFFER INTERACTIVE)" t)
(autoload 'htmlize-region "htmlize" "\
Convert the region to HTML, preserving colors and decorations.
See `htmlize-buffer' for details.

(fn BEG END &optional INTERACTIVE)" t)
(autoload 'htmlize-file "htmlize" "\
Load FILE, fontify it, convert it to HTML, and save the result.

Contents of FILE are inserted into a temporary buffer, whose major mode
is set with `normal-mode' as appropriate for the file type.  The buffer
is subsequently fontified with `font-lock' and converted to HTML.  Note
that, unlike `htmlize-buffer', this function explicitly turns on
font-lock.  If a form of highlighting other than font-lock is desired,
please use `htmlize-buffer' directly on buffers so highlighted.

Buffers currently visiting FILE are unaffected by this function.  The
function does not change current buffer or move the point.

If TARGET is specified and names a directory, the resulting file will be
saved there instead of to FILE's directory.  If TARGET is specified and
does not name a directory, it will be used as output file name.

(fn FILE &optional TARGET)" t)
(autoload 'htmlize-many-files "htmlize" "\
Convert FILES to HTML and save the corresponding HTML versions.

FILES should be a list of file names to convert.  This function calls
`htmlize-file' on each file; see that function for details.  When
invoked interactively, you are prompted for a list of files to convert,
terminated with RET.

If TARGET-DIRECTORY is specified, the HTML files will be saved to that
directory.  Normally, each HTML file is saved to the directory of the
corresponding source file.

(fn FILES &optional TARGET-DIRECTORY)" t)
(autoload 'htmlize-many-files-dired "htmlize" "\
HTMLize dired-marked files.

(fn ARG &optional TARGET-DIRECTORY)" t)
(register-definition-prefixes "htmlize" '("htmlize-"))


(provide 'htmlize-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/hl-todo-20240415.1538/hl-todo-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/hl-todo-20240415.1538/hl-todo-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'hl-todo-mode "hl-todo" "\
Highlight TODO and similar keywords in comments and strings.

This is a minor mode.  If called interactively, toggle the
`Hl-Todo mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `hl-todo-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(put 'global-hl-todo-mode 'globalized-minor-mode t)
(defvar global-hl-todo-mode nil "\
Non-nil if Global Hl-Todo mode is enabled.
See the `global-hl-todo-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-hl-todo-mode'.")
(custom-autoload 'global-hl-todo-mode "hl-todo" nil)
(autoload 'global-hl-todo-mode "hl-todo" "\
Toggle Hl-Todo mode in all buffers.
With prefix ARG, enable Global Hl-Todo mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Hl-Todo mode is enabled in all buffers where
`hl-todo--turn-on-mode-if-desired' would do it.

See `hl-todo-mode' for more information on Hl-Todo mode.

(fn &optional ARG)" t)
(autoload 'hl-todo-next "hl-todo" "\
Jump to the next TODO or similar keyword.
The prefix argument ARG specifies how many keywords to move.
A negative argument means move backward that many keywords.

(fn ARG)" t)
(autoload 'hl-todo-previous "hl-todo" "\
Jump to the previous TODO or similar keyword.
The prefix argument ARG specifies how many keywords to move.
A negative argument means move forward that many keywords.

(fn ARG)" t)
(autoload 'hl-todo-occur "hl-todo" "\
Use `occur' to find all TODO or similar keywords.
This actually finds a superset of the highlighted keywords,
because it uses a regexp instead of a more sophisticated
matcher.  It also finds occurrences that are not within a
string or comment." t)
(autoload 'hl-todo-rgrep "hl-todo" "\
Use `rgrep' to find all TODO or similar keywords.
This actually finds a superset of the highlighted keywords,
because it uses a regexp instead of a more sophisticated
matcher.  It also finds occurrences that are not within a
string or comment.  See `rgrep' for the meaning of REGEXP,
FILES, DIR and CONFIRM, except that the type of prefix
argument does not matter; with any prefix you can edit the
constructed shell command line before it is executed.
Also see option `hl-todo-keyword-faces'.

(fn REGEXP &optional FILES DIR CONFIRM)" t)
(autoload 'hl-todo-flymake "hl-todo" "\
Flymake backend for `hl-todo-mode'.
Diagnostics are reported to REPORT-FN.  Use `add-hook' to
register this function in `flymake-diagnostic-functions' before
enabling `flymake-mode'.

(fn REPORT-FN &rest PLIST)")
(autoload 'hl-todo-insert "hl-todo" "\
Read a TODO or similar keyword and insert it at point.

If point is not inside a string or comment, then insert a new
comment.  If point is at the end of the line, then insert the
comment there, otherwise insert it as a new line before the
current line.  When called interactively the KEYWORD is read
via `completing-read'.

If `hl-todo-require-punctuation' is non-nil and
`hl-todo-highlight-punctuation' contains a single character,
then append that character to the inserted string.

(fn KEYWORD)" t)
(register-definition-prefixes "hl-todo" '("hl-todo-"))


(provide 'hl-todo-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/haskell-mode-20240116.1718/haskell-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/haskell-mode-20240116.1718/haskell-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'ghc-core-create-core "ghc-core" "\
Compile and load the current buffer as tidy core." t)
(add-to-list 'auto-mode-alist '("\\.hcr\\'" . ghc-core-mode))
(add-to-list 'auto-mode-alist '("\\.dump-simpl\\'" . ghc-core-mode))
(autoload 'ghc-core-mode "ghc-core" "\
Major mode for GHC Core files.

(fn)" t)
(register-definition-prefixes "ghc-core" '("ghc-core-"))



(autoload 'ghci-script-mode "ghci-script-mode" "\
Major mode for working with .ghci files.

(fn)" t)
(add-to-list 'auto-mode-alist '("\\.ghci\\'" . ghci-script-mode))
(register-definition-prefixes "ghci-script-mode" '("ghci-script-mode-"))



(autoload 'interactive-haskell-mode "haskell" "\
Minor mode for enabling haskell-process interaction.

This is a minor mode.  If called interactively, toggle the
`Interactive-Haskell mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `interactive-haskell-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'haskell-interactive-mode-return "haskell" "\
Handle the return key." t)
(autoload 'haskell-session-kill "haskell" "\
Kill the session process and buffer, delete the session.
1. Kill the process.
2. Kill the interactive buffer unless LEAVE-INTERACTIVE-BUFFER is not given.
3. Walk through all the related buffers and set their haskell-session to nil.
4. Remove the session from the sessions list.

(fn &optional LEAVE-INTERACTIVE-BUFFER)" t)
(autoload 'haskell-interactive-kill "haskell" "\
Kill the buffer and (maybe) the session." t)
(autoload 'haskell-session "haskell" "\
Get the Haskell session, prompt if there isn't one or fail.")
(autoload 'haskell-interactive-switch "haskell" "\
Switch to the interactive mode for this session." t)
(autoload 'haskell-session-change "haskell" "\
Change the session for the current buffer." t)
(autoload 'haskell-kill-session-process "haskell" "\
Kill the process.

(fn &optional SESSION)" t)
(autoload 'haskell-interactive-mode-visit-error "haskell" "\
Visit the buffer of the current (or last) error message." t)
(autoload 'haskell-mode-jump-to-tag "haskell" "\
Jump to the tag of the given identifier.

Give optional NEXT-P parameter to override value of
`xref-prompt-for-identifier' during definition search.

(fn &optional NEXT-P)" t)
(autoload 'haskell-mode-after-save-handler "haskell" "\
Function that will be called after buffer's saving.")
(autoload 'haskell-mode-tag-find "haskell" "\
The tag find function, specific for the particular session.

(fn &optional NEXT-P)" t)
(autoload 'haskell-interactive-bring "haskell" "\
Bring up the interactive mode for this session." t)
(autoload 'haskell-process-load-file "haskell" "\
Load the current buffer file." t)
(autoload 'haskell-process-reload "haskell" "\
Re-load the current buffer file." t)
(autoload 'haskell-process-reload-file "haskell")
(autoload 'haskell-process-load-or-reload "haskell" "\
Load or reload. Universal argument toggles which.

(fn &optional TOGGLE)" t)
(autoload 'haskell-process-cabal-build "haskell" "\
Build the Cabal project." t)
(autoload 'haskell-process-cabal "haskell" "\
Prompts for a Cabal command to run.

(fn P)" t)
(autoload 'haskell-process-minimal-imports "haskell" "\
Dump minimal imports." t)
(register-definition-prefixes "haskell" '("haskell-" "interactive-haskell-mode-map" "xref-prompt-for-identifier"))



(autoload 'haskell-align-imports "haskell-align-imports" "\
Align all the imports in the buffer." t)
(register-definition-prefixes "haskell-align-imports" '("haskell-align-imports-"))



(add-to-list 'auto-mode-alist '("\\.chs\\'" . haskell-c2hs-mode))
(autoload 'haskell-c2hs-mode "haskell-c2hs" "\
Mode for editing *.chs files of the c2hs haskell tool.

(fn)" t)
(register-definition-prefixes "haskell-c2hs" '("haskell-c2hs-font-lock-keywords"))



(add-to-list 'auto-mode-alist '("\\.cabal\\'\\|/cabal\\.project\\|/\\.cabal/config\\'" . haskell-cabal-mode))
(autoload 'haskell-cabal-mode "haskell-cabal" "\
Major mode for Cabal package description files.

(fn)" t)
(autoload 'haskell-cabal-get-field "haskell-cabal" "\
Read the value of field with NAME from project's cabal file.
If there is no valid .cabal file to get the setting from (or
there is no corresponding setting with that name in the .cabal
file), then this function returns nil.

(fn NAME)" t)
(autoload 'haskell-cabal-get-dir "haskell-cabal" "\
Get the Cabal dir for a new project.
Various ways of figuring this out, and indeed just prompting the user.  Do them
all.

(fn &optional USE-DEFAULTS)")
(autoload 'haskell-cabal-visit-file "haskell-cabal" "\
Locate and visit package description file for file visited by current buffer.
This uses `haskell-cabal-find-file' to locate the closest
\".cabal\" file and open it.  This command assumes a common Cabal
project structure where the \".cabal\" file is in the top-folder
of the project, and all files related to the project are in or
below the top-folder.  If called with non-nil prefix argument
OTHER-WINDOW use `find-file-other-window'.

(fn OTHER-WINDOW)" t)
(register-definition-prefixes "haskell-cabal" '("haskell-"))



(autoload 'haskell-collapse-mode "haskell-collapse" "\
Minor mode to collapse and expand haskell expressions

This is a minor mode.  If called interactively, toggle the
`Haskell-Collapse mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `haskell-collapse-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "haskell-collapse" '("haskell-"))



(autoload 'haskell-process-restart "haskell-commands" "\
Restart the inferior Haskell process." t)
(autoload 'haskell-process-clear "haskell-commands" "\
Clear the current process." t)
(autoload 'haskell-process-interrupt "haskell-commands" "\
Interrupt the process (SIGINT)." t)
(autoload 'haskell-describe "haskell-commands" "\
Describe the given identifier IDENT.

(fn IDENT)" t)
(autoload 'haskell-rgrep "haskell-commands" "\
Grep the effective project for the symbol at point.
Very useful for codebase navigation.

Prompts for an arbitrary regexp given a prefix arg PROMPT.

(fn &optional PROMPT)" t)
(autoload 'haskell-process-do-info "haskell-commands" "\
Print info on the identifier at point.
If PROMPT-VALUE is non-nil, request identifier via mini-buffer.

(fn &optional PROMPT-VALUE)" t)
(autoload 'haskell-process-do-type "haskell-commands" "\
Print the type of the given expression.

Given INSERT-VALUE prefix indicates that result type signature
should be inserted.

(fn &optional INSERT-VALUE)" t)
(autoload 'haskell-mode-jump-to-def-or-tag "haskell-commands" "\
Jump to the definition.
Jump to definition of identifier at point by consulting GHCi, or
tag table as fallback.

Remember: If GHCi is busy doing something, this will delay, but
it will always be accurate, in contrast to tags, which always
work but are not always accurate.
If the definition or tag is found, the location from which you jumped
will be pushed onto `xref--marker-ring', so you can return to that
position with `xref-pop-marker-stack'.

(fn &optional NEXT-P)" t)
(autoload 'haskell-mode-goto-loc "haskell-commands" "\
Go to the location of the thing at point.
Requires the :loc-at command from GHCi." t)
(autoload 'haskell-mode-jump-to-def "haskell-commands" "\
Jump to definition of identifier IDENT at point.

(fn IDENT)" t)
(autoload 'haskell-process-cd "haskell-commands" "\
Change directory.

(fn &optional NOT-INTERACTIVE)" t)
(autoload 'haskell-process-cabal-macros "haskell-commands" "\
Send the cabal macros string." t)
(autoload 'haskell-mode-show-type-at "haskell-commands" "\
Show type of the thing at point or within active region asynchronously.
This function requires GHCi 8+ or GHCi-ng.

\\<haskell-interactive-mode-map>
To make this function works sometimes you need to load the file in REPL
first using command `haskell-process-load-file' bound to
\\[haskell-process-load-file].

Optional argument INSERT-VALUE indicates that
recieved type signature should be inserted (but only if nothing
happened since function invocation).

(fn &optional INSERT-VALUE)" t)
(autoload 'haskell-process-unignore "haskell-commands" "\
Unignore any ignored files.
Do not ignore files that were specified as being ignored by the
inferior GHCi process." t)
(autoload 'haskell-session-change-target "haskell-commands" "\
Set the build TARGET for cabal REPL.

(fn TARGET)" t)
(autoload 'haskell-mode-stylish-buffer "haskell-commands" "\
Apply stylish-haskell to the current buffer.

Use `haskell-mode-stylish-haskell-path' to know where to find
stylish-haskell executable.  This function tries to preserve
cursor position and markers by using
`haskell-mode-buffer-apply-command'." t)
(autoload 'haskell-mode-find-uses "haskell-commands" "\
Find use cases of the identifier at point and highlight them all." t)
(register-definition-prefixes "haskell-commands" '("haskell-"))



(autoload 'haskell-compile "haskell-compile" "\
Run a compile command for the current Haskell buffer.
Obeys haskell-compiler-type to choose the appropriate build command.

If prefix argument EDIT-COMMAND is non-nil (and not a negative
prefix `-'), prompt for a custom compile command.

If EDIT-COMMAND contains the negative prefix argument `-', call
the alternative command defined in
`haskell-compile-stack-build-alt-command' /
`haskell-compile-cabal-build-alt-command'.

If there is no prefix argument, the most recent custom compile
command is used, falling back to
`haskell-compile-stack-build-command' for stack builds
`haskell-compile-cabal-build-command' for cabal builds, and
`haskell-compile-command' otherwise.

'% characters in the `-command' templates are replaced by the
base directory for build tools, or the current buffer for
`haskell-compile-command'.

(fn &optional EDIT-COMMAND)" t)
(register-definition-prefixes "haskell-compile" '("haskell-"))



(register-definition-prefixes "haskell-complete-module" '("haskell-complete-module"))



(autoload 'haskell-completions-completion-at-point "haskell-completions" "\
Provide completion list for thing at point.
This function is used in non-interactive `haskell-mode'.  It
provides completions for haskell keywords, language pragmas,
GHC's options, and language extensions, but not identifiers.")
(register-definition-prefixes "haskell-completions" '("haskell-completions-"))



(register-definition-prefixes "haskell-customize" '("haskell-" "inferior-haskell-root-dir"))



(register-definition-prefixes "haskell-debug" '("haskell-debug"))



(autoload 'haskell-ds-create-imenu-index "haskell-decl-scan" "\
Function for finding `imenu' declarations in Haskell mode.
Finds all declarations (classes, variables, imports, instances and
datatypes) in a Haskell file for the `imenu' package.")
(autoload 'turn-on-haskell-decl-scan "haskell-decl-scan" "\
Unconditionally activate `haskell-decl-scan-mode'." t)
(autoload 'haskell-decl-scan-mode "haskell-decl-scan" "\
Toggle Haskell declaration scanning minor mode on or off.
With a prefix argument ARG, enable minor mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.

See also info node `(haskell-mode)haskell-decl-scan-mode' for
more details about this minor mode.

Top-level declarations are scanned and listed in the menu item
\"Declarations\" (if enabled via option
`haskell-decl-scan-add-to-menubar').  Selecting an item from this
menu will take point to the start of the declaration.

\\[beginning-of-defun] and \\[end-of-defun] move forward and backward to the start of a declaration.

This may link with `haskell-doc-mode'.

For non-literate and LaTeX-style literate scripts, we assume the
common convention that top-level declarations start at the first
column.  For Bird-style literate scripts, we assume the common
convention that top-level declarations start at the third column,
ie. after \"> \".

Anything in `font-lock-comment-face' is not considered for a
declaration.  Therefore, using Haskell font locking with comments
coloured in `font-lock-comment-face' improves declaration scanning.

Literate Haskell scripts are supported: If the value of
`haskell-literate' (set automatically by `haskell-literate-mode')
is `bird', a Bird-style literate script is assumed.  If it is nil
or `tex', a non-literate or LaTeX-style literate script is
assumed, respectively.

Invokes `haskell-decl-scan-mode-hook' on activation.

(fn &optional ARG)" t)
(register-definition-prefixes "haskell-decl-scan" '("haskell-d" "literate-haskell-ds-"))



(autoload 'haskell-doc-mode "haskell-doc" "\
Enter `haskell-doc-mode' for showing fct types in the echo area.

When enabled, shows the type of the function near point or a related comment.

If the identifier near point is a Haskell keyword and the variable
`haskell-doc-show-reserved' is non-nil show a one line summary
of the syntax.

If the identifier near point is a Prelude or one of the standard library
functions and `haskell-doc-show-prelude' is non-nil show its type.

If the identifier near point is local (i.e. defined in this module) check
the `imenu' list of functions for the type.  This obviously requires that
your language mode uses `imenu'.

If the identifier near point is global (i.e. defined in an imported module)
and the variable `haskell-doc-show-global-types' is non-nil show the type of its
function.

If the identifier near point is a standard strategy or a function, type related
related to strategies and `haskell-doc-show-strategy' is non-nil show the type
of the function.  Strategies are special to the parallel execution of Haskell.
If you're not interested in that just turn it off.

If the identifier near point is a user defined function that occurs as key
in the alist `haskell-doc-user-defined-ids' and the variable
`haskell-doc-show-user-defined' is non-nil show the type of the function.

This variable is buffer-local.

This is a minor mode.  If called interactively, toggle the
`Haskell-Doc mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `haskell-doc-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(defalias 'turn-on-haskell-doc-mode 'haskell-doc-mode)
(defalias 'turn-on-haskell-doc 'haskell-doc-mode)
(autoload 'haskell-doc-eldoc-function "haskell-doc" "\
Function for use by eldoc.

By accepting CALLBACK, it is designed to be used in
`eldoc-documentation-functions' in Emacs >= 28.1, but by making
that argument optional it can also be set directly as
`eldoc-documentation-function' in older Emacsen.

(fn &optional CALLBACK)")
(autoload 'haskell-doc-current-info "haskell-doc" "\
Return the info about symbol at point.
Meant for `eldoc-documentation-function'.")
(autoload 'haskell-doc-show-type "haskell-doc" "\
Show the type of the function near point or given symbol SYM.
For the function under point, show the type in the echo area.
This information is extracted from the `haskell-doc-prelude-types' alist
of prelude functions and their types, or from the local functions in the
current buffer.

(fn &optional SYM)" t)
(register-definition-prefixes "haskell-doc" '("haskell-" "inferior-haskell-" "turn-off-haskell-doc"))



(register-definition-prefixes "haskell-font-lock" '("haskell-"))



(register-definition-prefixes "haskell-ghc-support" '("haskell-"))



(autoload 'haskell-hoogle "haskell-hoogle" "\
Do a Hoogle search for QUERY.

If prefix argument INFO is given, then `haskell-hoogle-command'
is asked to show extra info for the items matching QUERY..

(fn QUERY &optional INFO)" t)
(defalias 'hoogle 'haskell-hoogle)
(autoload 'haskell-hoogle-lookup-from-website "haskell-hoogle" "\
Lookup QUERY at `haskell-hoogle-url'.

(fn QUERY)" t)
(autoload 'haskell-hoogle-lookup-from-local "haskell-hoogle" "\
Lookup QUERY on local hoogle server." t)
(register-definition-prefixes "haskell-hoogle" '("haskell-hoogle-" "hoogle-prompt"))



(autoload 'turn-on-haskell-indent "haskell-indent" "\
Turn on ``intelligent'' Haskell indentation mode.")
(autoload 'haskell-indent-mode "haskell-indent" "\
``Intelligent'' Haskell indentation mode.
This deals with the layout rule of Haskell.
\\[haskell-indent-cycle] starts the cycle which proposes new
possibilities as long as the TAB key is pressed.  Any other key
or mouse click terminates the cycle and is interpreted except for
RET which merely exits the cycle.
Other special keys are:
    \\[haskell-indent-insert-equal]
      inserts an =
    \\[haskell-indent-insert-guard]
      inserts an |
    \\[haskell-indent-insert-otherwise]
      inserts an | otherwise =
these functions also align the guards and rhs of the current definition
    \\[haskell-indent-insert-where]
      inserts a where keyword
    \\[haskell-indent-align-guards-and-rhs]
      aligns the guards and rhs of the region
    \\[haskell-indent-put-region-in-literate]
      makes the region a piece of literate code in a literate script

If `ARG' is falsey, toggle `haskell-indent-mode'.  Else sets
`haskell-indent-mode' to whether `ARG' is greater than 0.

Invokes `haskell-indent-hook' if not nil.

(fn &optional ARG)" t)
(register-definition-prefixes "haskell-indent" '("haskell-indent-" "turn-off-haskell-indent"))



(autoload 'haskell-indentation-mode "haskell-indentation" "\
Haskell indentation mode that deals with the layout rule.

It rebinds RET, DEL and BACKSPACE, so that indentations can be
set and deleted as if they were real tabs.

This is a minor mode.  If called interactively, toggle the
`Haskell-Indentation mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `haskell-indentation-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'turn-on-haskell-indentation "haskell-indentation" "\
Turn on the haskell-indentation minor mode." t)
(register-definition-prefixes "haskell-indentation" '("haskell-indentation-"))



(autoload 'haskell-interactive-mode-reset-error "haskell-interactive-mode" "\
Reset the error cursor position.

(fn SESSION)" t)
(autoload 'haskell-interactive-mode-echo "haskell-interactive-mode" "\
Echo a read only piece of text before the prompt.

(fn SESSION MESSAGE &optional MODE)")
(autoload 'haskell-process-show-repl-response "haskell-interactive-mode" "\
Send LINE to the GHCi process and echo the result in some fashion.
Result will be printed in the minibuffer or presented using
function `haskell-presentation-present', depending on variable
`haskell-process-use-presentation-mode'.

(fn LINE)")
(register-definition-prefixes "haskell-interactive-mode" '("haskell-"))



(register-definition-prefixes "haskell-lexeme" '("haskell-lexeme-"))



(autoload 'haskell-process-reload-devel-main "haskell-load" "\
Reload the module `DevelMain' and then run `DevelMain.update'.

This is for doing live update of the code of servers or GUI
applications.  Put your development version of the program in
`DevelMain', and define `update' to auto-start the program on a
new thread, and use the `foreign-store' package to access the
running context across :load/:reloads in GHCi." t)
(register-definition-prefixes "haskell-load" '("haskell-"))



(autoload 'haskell-menu "haskell-menu" "\
Launch the Haskell sessions menu." t)
(register-definition-prefixes "haskell-menu" '("haskell-menu-"))



(autoload 'haskell-version "haskell-mode" "\
Show the `haskell-mode` version in the echo area.
With prefix argument HERE, insert it at point.

(fn &optional HERE)" t)
(autoload 'haskell-mode-view-news "haskell-mode" "\
Display information on recent changes to haskell-mode." t)
(autoload 'haskell-mode "haskell-mode" "\
Major mode for editing Haskell programs.

\\<haskell-mode-map>

Literate Haskell scripts are supported via `haskell-literate-mode'.
The variable `haskell-literate' indicates the style of the script in the
current buffer.  See the documentation on this variable for more details.

Use `haskell-version' to find out what version of Haskell mode you are
currently using.

Additional Haskell mode modules can be hooked in via `haskell-mode-hook'.

Indentation modes:

    `haskell-indentation-mode', Kristof Bastiaensen, Gergely Risko
      Intelligent semi-automatic indentation Mk2

    `haskell-indent-mode', Guy Lapalme
      Intelligent semi-automatic indentation.

Interaction modes:

    `interactive-haskell-mode'
      Interact with per-project GHCi processes through a REPL and
      directory-aware sessions.

Other modes:

    `haskell-decl-scan-mode', Graeme E Moss
      Scans top-level declarations, and places them in a menu.

    `haskell-doc-mode', Hans-Wolfgang Loidl
      Sets up eldoc to echo types of functions or syntax of keywords
      when the cursor is idle.

To activate a minor-mode, simply run the interactive command. For
example, `M-x haskell-doc-mode'. Run it again to disable it.

To enable a mode for every `haskell-mode' buffer, add a hook in
your Emacs configuration. To do that you can customize
`haskell-mode-hook' or add lines to your .emacs file. For
example, to enable `interactive-haskell-mode', use the following:

    (add-hook \\='haskell-mode-hook \\='interactive-haskell-mode)

Minor modes that work well with `haskell-mode':

- `smerge-mode': show and work with diff3 conflict markers used
  by git, svn and other version control systems.

(fn)" t)
(autoload 'haskell-forward-sexp "haskell-mode" "\
Haskell specific version of `forward-sexp'.

Move forward across one balanced expression (sexp).  With ARG, do
it that many times.  Negative arg -N means move backward across N
balanced expressions.  This command assumes point is not in a
string or comment.

If unable to move over a sexp, signal `scan-error' with three
arguments: a message, the start of the obstacle (a parenthesis or
list marker of some kind), and end of the obstacle.

(fn &optional ARG)" t)
(autoload 'haskell-literate-mode "haskell-mode" "\
As `haskell-mode' but for literate scripts.

(fn)" t)
(define-obsolete-function-alias 'literate-haskell-mode 'haskell-literate-mode "2020-04")
(add-to-list 'auto-mode-alist '("\\.[gh]s\\'" . haskell-mode))
(add-to-list 'auto-mode-alist '("\\.hsig\\'" . haskell-mode))
(add-to-list 'auto-mode-alist '("\\.l[gh]s\\'" . haskell-literate-mode))
(add-to-list 'auto-mode-alist '("\\.hsc\\'" . haskell-mode))
(add-to-list 'interpreter-mode-alist '("runghc" . haskell-mode))
(add-to-list 'interpreter-mode-alist '("runhaskell" . haskell-mode))
(add-to-list 'completion-ignored-extensions ".hi")
(autoload 'haskell-mode-generate-tags "haskell-mode" "\
Generate tags using Hasktags.  This is synchronous function.

If optional AND-THEN-FIND-THIS-TAG argument is present it is used
with function `xref-find-definitions' after new table was
generated.

(fn &optional AND-THEN-FIND-THIS-TAG)" t)
(register-definition-prefixes "haskell-mode" '("haskell-"))



(autoload 'haskell-session-installed-modules "haskell-modules" "\
Get the modules installed in the current package set.

(fn SESSION &optional DONTCREATE)")
(autoload 'haskell-session-all-modules "haskell-modules" "\
Get all modules -- installed or in the current project.
If DONTCREATE is non-nil don't create a new session.

(fn SESSION &optional DONTCREATE)")
(autoload 'haskell-session-project-modules "haskell-modules" "\
Get the modules of the current project.
If DONTCREATE is non-nil don't create a new session.

(fn SESSION &optional DONTCREATE)")
(register-definition-prefixes "haskell-modules" '("haskell-"))



(autoload 'haskell-move-nested "haskell-move-nested" "\
Shift the nested off-side-rule block adjacent to point.
It shift the nested off-side-rule block adjacent to point by COLS
columns to the right.

In Transient Mark mode, if the mark is active, operate on the contents
of the region instead.

(fn COLS)")
(autoload 'haskell-move-nested-right "haskell-move-nested" "\
Increase indentation of the following off-side-rule block adjacent to point.

Use a numeric prefix argument to indicate amount of indentation to apply.

In Transient Mark mode, if the mark is active, operate on the contents
of the region instead.

(fn COLS)" t)
(autoload 'haskell-move-nested-left "haskell-move-nested" "\
Decrease indentation of the following off-side-rule block adjacent to point.

Use a numeric prefix argument to indicate amount of indentation to apply.

In Transient Mark mode, if the mark is active, operate on the contents
of the region instead.

(fn COLS)" t)
(register-definition-prefixes "haskell-move-nested" '("haskell-"))



(autoload 'haskell-navigate-imports "haskell-navigate-imports" "\
Cycle the Haskell import lines or return to point (with prefix arg).

(fn &optional RETURN)" t)
(autoload 'haskell-navigate-imports-go "haskell-navigate-imports" "\
Go to the first line of a list of consecutive import lines. Cycles." t)
(autoload 'haskell-navigate-imports-return "haskell-navigate-imports" "\
Return to the non-import point we were at before going to the module list.
   If we were originally at an import list, we can just cycle through easily." t)
(register-definition-prefixes "haskell-navigate-imports" '("haskell-navigate-imports-"))



(register-definition-prefixes "haskell-presentation-mode" '("haskell-presentation-"))



(register-definition-prefixes "haskell-process" '("haskell-"))



(register-definition-prefixes "haskell-repl" '("haskell-interactive-"))



(register-definition-prefixes "haskell-sandbox" '("haskell-sandbox-"))



(autoload 'haskell-session-maybe "haskell-session" "\
Maybe get the Haskell session, return nil if there isn't one.")
(autoload 'haskell-session-process "haskell-session" "\
Get the session process.

(fn S)")
(register-definition-prefixes "haskell-session" '("haskell-session"))



(autoload 'haskell-sort-imports "haskell-sort-imports" "\
Sort the import list at point. It sorts the current group
i.e. an import list separated by blank lines on either side.

If the region is active, it will restrict the imports to sort
within that region." t)
(register-definition-prefixes "haskell-sort-imports" '("haskell-sort-imports-"))



(register-definition-prefixes "haskell-string" '("haskell-"))



(register-definition-prefixes "haskell-svg" '("haskell-svg-"))



(autoload 'haskell-unicode-input-method-enable "haskell-unicode-input-method" "\
Set input method `haskell-unicode'." t)
(define-obsolete-function-alias 'turn-on-haskell-unicode-input-method 'haskell-unicode-input-method-enable "2020-04")



(register-definition-prefixes "haskell-utils" '("haskell-"))



(autoload 'highlight-uses-mode "highlight-uses-mode" "\
Minor mode for highlighting and jumping between uses.

This is a minor mode.  If called interactively, toggle the
`Highlight-Uses mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `highlight-uses-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "highlight-uses-mode" '("highlight-uses-mode-"))



(autoload 'run-haskell "inf-haskell" "\
Show the inferior-haskell buffer.  Start the process if needed." t)
(register-definition-prefixes "inf-haskell" '("haskell-" "inf"))



(register-definition-prefixes "w3m-haddock" '("haskell-w3m-" "w3m-haddock-"))


(provide 'haskell-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/autothemer-20230414.1419/autothemer-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/autothemer-20230414.1419/autothemer-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'autothemer-deftheme "autothemer" "\
Define a theme NAME with description DESCRIPTION.
A color PALETTE can be used to define `let*'-like
bindings within both the REDUCED-SPECS and the BODY.

(fn NAME DESCRIPTION PALETTE REDUCED-SPECS &rest BODY)" nil t)
(autoload 'autothemer-insert-missing-face "autothemer" "\
Insert a face spec template for an unthemed face.
An approximate color from the palette will be used for
color attributes." t)
(autoload 'autothemer-insert-missing-faces "autothemer" "\
Insert face spec templates for unthemed faces matching REGEXP.
An error is shown when no current theme is available.

(fn &optional REGEXP)" t)
(autoload 'autothemer-generate-templates-filtered "autothemer" "\
Autogenerate customizations for unthemed faces matching REGEXP.

Calls `autothemer-generate-templates' after user provides REGEXP interactively.

(fn REGEXP)" t)
(autoload 'autothemer-generate-templates "autothemer" "\
Autogenerate customizations for unthemed faces (optionally by REGEXP).

Generate customizations that approximate current face definitions using the
nearest colors in the color palette of `autothemer-current-theme'.

An error is shown when no current theme is available.

(fn &optional REGEXP)" t)
(register-definition-prefixes "autothemer" '("autothemer-"))


(provide 'autothemer-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/gruvbox-theme-20240515.553/gruvbox-theme-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/gruvbox-theme-20240515.553/gruvbox-theme-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))
(register-definition-prefixes "gruvbox" '("gruvbox-"))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))



(and load-file-name (boundp 'custom-theme-load-path) (add-to-list 'custom-theme-load-path (file-name-as-directory (file-name-directory load-file-name))))


(provide 'gruvbox-theme-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/goto-chg-20240407.1110/goto-chg-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/goto-chg-20240407.1110/goto-chg-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'goto-last-change "goto-chg" "\
Go to the point where the last edit was made in the current buffer.
Repeat the command to go to the second last edit, etc.

To go back to more recent edit, the reverse of this command, use \\[goto-last-change-reverse]
or precede this command with \\[universal-argument] - (minus).

It does not go to the same point twice even if there has been many edits
there. I call the minimal distance between distinguishable edits \"span\".
Set variable `glc-default-span' to control how close is \"the same point\".
Default span is 8.
The span can be changed temporarily with \\[universal-argument] right before \\[goto-last-change]:
\\[universal-argument] <NUMBER> set current span to that number,
\\[universal-argument] (no number) multiplies span by 4, starting with default.
The so set span remains until it is changed again with \\[universal-argument], or the consecutive
repetition of this command is ended by any other command.

When span is zero (i.e. \\[universal-argument] 0) subsequent \\[goto-last-change] visits each and
every point of edit and a message shows what change was made there.
In this case it may go to the same point twice.

This command uses undo information. If undo is disabled, so is this command.
At times, when undo information becomes too large, the oldest information is
discarded. See variable `undo-limit'.

(fn ARG)" t)
(autoload 'goto-last-change-reverse "goto-chg" "\
Go back to more recent changes after \\[goto-last-change] have been used.
See `goto-last-change' for use of prefix argument.

(fn ARG)" t)
(register-definition-prefixes "goto-chg" '("glc-"))


(provide 'goto-chg-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/frame-local-20180330.940/frame-local-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/frame-local-20180330.940/frame-local-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "frame-local" '("frame-local-"))


(provide 'frame-local-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/evil-20240513.2118/evil-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/evil-20240513.2118/evil-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(register-definition-prefixes "evil-command-window" '("evil-"))



(register-definition-prefixes "evil-commands" '("evil-"))



(register-definition-prefixes "evil-common" '("bounds-of-evil-" "evil-" "forward-evil-"))



 (autoload 'evil-mode "evil" nil t)
(register-definition-prefixes "evil-core" '("evil-" "turn-o"))



(autoload 'evil-digraph "evil-digraphs" "\
Convert DIGRAPH to character or list representation.
If DIGRAPH is a list (CHAR1 CHAR2), return the corresponding character;
if DIGRAPH is a character, return the corresponding list.
Searches in `evil-digraphs-table-user' and `evil-digraphs-table'.

(fn DIGRAPH)")
(register-definition-prefixes "evil-digraphs" '("evil-digraphs-table"))



(register-definition-prefixes "evil-ex" '("evil-"))



(register-definition-prefixes "evil-integration" '("evil-"))



(register-definition-prefixes "evil-jumps" '("evil-"))



(register-definition-prefixes "evil-macros" '("evil-"))



(register-definition-prefixes "evil-maps" '("evil-"))



(register-definition-prefixes "evil-repeat" '("evil-"))



(register-definition-prefixes "evil-search" '("evil-"))



(register-definition-prefixes "evil-states" '("evil-"))



(register-definition-prefixes "evil-types" '("evil-ex-get-optional-register-and-count"))



(register-definition-prefixes "evil-vars" '("evil-"))


(provide 'evil-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/evil-tutor-20150103.653/evil-tutor-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/evil-tutor-20150103.653/evil-tutor-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'evil-tutor-start "evil-tutor" "\
Start a evil-tutor session." t)
(defalias 'evil-tutor-resume 'evil-tutor-start)
(register-definition-prefixes "evil-tutor" '("evil-tutor-"))


(provide 'evil-tutor-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/annalist-20240501.1201/annalist-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/annalist-20240501.1201/annalist-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'annalist-record "annalist" "\
In the store for ANNALIST, TYPE, and LOCAL, record RECORD.
ANNALIST should correspond to the package/user recording this information (e.g.
'general, 'me, etc.). TYPE is the type of information being recorded (e.g.
'keybindings). LOCAL corresponds to whether to store RECORD only for the current
buffer. This information together is used to select where RECORD should be
stored in and later retrieved from with `annalist-describe'. RECORD should be a
list of items to record and later print as org headings and column entries in a
single row. If PLIST is non-nil, RECORD should be a plist instead of an ordered
list (e.g. '(keymap org-mode-map key \"C-c a\" ...)). The plist keys should be
the symbols used for the definition of TYPE.

(fn ANNALIST TYPE RECORD &key LOCAL PLIST)")
(autoload 'annalist-describe "annalist" "\
Describe information recorded by ANNALIST for TYPE.
For example: (annalist-describe 'general 'keybindings) If VIEW is non-nil, use
those settings for displaying recorded information instead of the defaults.

(fn ANNALIST TYPE &optional VIEW)")
(register-definition-prefixes "annalist" '("annalist-"))


(provide 'annalist-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/evil-collection-20240417.1647/evil-collection-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/evil-collection-20240417.1647/evil-collection-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'evil-collection-translate-minor-mode-key "evil-collection" "\
Translate keys in the keymap(s) corresponding to STATES and MODES.

Similar to `evil-collection-translate-key' but for minor modes.
STATES should be the name of an evil state, a list of states, or nil. MODES
should be a symbol corresponding to minor-mode to make the translations in or a
list of minor-mode symbols. TRANSLATIONS corresponds to a list of
key replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to
\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a
key. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial
invocation, and future invocations will always look up keys in the backup
keymap. When no TRANSLATIONS are given, this function will only create the
backup keymap without making any translations. On the other hand, if DESTRUCTIVE
is non-nil, the keymap will be destructively altered without creating a backup.
For example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"
would continue to swap and unswap the definitions of these keys. This means that
when DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same
invocation.

(fn STATES MODES &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)")
(function-put 'evil-collection-translate-minor-mode-key 'lisp-indent-function 'defun)
(autoload 'evil-collection-translate-key "evil-collection" "\
Translate keys in the keymap(s) corresponding to STATES and KEYMAPS.
STATES should be the name of an evil state, a list of states, or nil. KEYMAPS
should be a symbol corresponding to the keymap to make the translations in or a
list of keymap symbols. Like `evil-define-key', when a keymap does not exist,
the keybindings will be deferred until the keymap is defined, so
`with-eval-after-load' is not necessary. TRANSLATIONS corresponds to a list of
key replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to
\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a
key. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial
invocation, and future invocations will always look up keys in the backup
keymap. When no TRANSLATIONS are given, this function will only create the
backup keymap without making any translations. On the other hand, if DESTRUCTIVE
is non-nil, the keymap will be destructively altered without creating a backup.
For example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"
would continue to swap and unswap the definitions of these keys. This means that
when DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same
invocation.

(fn STATES KEYMAPS &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)")
(function-put 'evil-collection-translate-key 'lisp-indent-function 'defun)
(autoload 'evil-collection-swap-key "evil-collection" "\
Wrapper around `evil-collection-translate-key' for swapping keys.
STATES, KEYMAPS, and ARGS are passed to `evil-collection-translate-key'. ARGS
should consist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\"
\"a\" with `evil-collection-translate-key') and optionally keyword arguments for
`evil-collection-translate-key'.

(fn STATES KEYMAPS &rest ARGS)" nil t)
(function-put 'evil-collection-swap-key 'lisp-indent-function 'defun)
(autoload 'evil-collection-swap-minor-mode-key "evil-collection" "\
Wrapper around `evil-collection-translate-minor-mode-key' for swapping keys.
STATES, MODES, and ARGS are passed to
`evil-collection-translate-minor-mode-key'. ARGS should consist of key swaps
(e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\" \"a\"
with `evil-collection-translate-minor-mode-key') and optionally keyword
arguments for `evil-collection-translate-minor-mode-key'.

(fn STATES MODES &rest ARGS)" nil t)
(function-put 'evil-collection-swap-minor-mode-key 'lisp-indent-function 'defun)
(autoload 'evil-collection-require "evil-collection" "\
Require the evil-collection-MODE file, but do not activate it.

MODE should be a symbol. This requires the evil-collection-MODE
feature without needing to manipulate `load-path'. NOERROR is
forwarded to `require'.

(fn MODE &optional NOERROR)")
(autoload 'evil-collection-init "evil-collection" "\
Register the Evil bindings for all modes in `evil-collection-mode-list'.

Alternatively, you may register select bindings manually, for
instance:

  (with-eval-after-load ='calendar
    (evil-collection-calendar-setup))

If MODES is specified (as either one mode or a list of modes), use those modes
instead of the modes in `evil-collection-mode-list'.

(fn &optional MODES)" t)
(register-definition-prefixes "evil-collection" '("evil-collection-"))


(provide 'evil-collection-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/doom-modeline-20240510.144/doom-modeline-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/doom-modeline-20240510.144/doom-modeline-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'doom-modeline-set-main-modeline "doom-modeline" "\
Set main mode-line.
If DEFAULT is non-nil, set the default mode-line for all buffers.

(fn &optional DEFAULT)")
(defvar doom-modeline-mode nil "\
Non-nil if Doom-Modeline mode is enabled.
See the `doom-modeline-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `doom-modeline-mode'.")
(custom-autoload 'doom-modeline-mode "doom-modeline" nil)
(autoload 'doom-modeline-mode "doom-modeline" "\
Toggle `doom-modeline' on or off.

This is a global minor mode.  If called interactively, toggle the
`Doom-Modeline mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='doom-modeline-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "doom-modeline" '("doom-modeline-"))



(register-definition-prefixes "doom-modeline-core" '("doom-modeline"))



 (autoload 'doom-modeline-env-setup-python "doom-modeline-env")
 (autoload 'doom-modeline-env-setup-ruby "doom-modeline-env")
 (autoload 'doom-modeline-env-setup-perl "doom-modeline-env")
 (autoload 'doom-modeline-env-setup-go "doom-modeline-env")
 (autoload 'doom-modeline-env-setup-elixir "doom-modeline-env")
 (autoload 'doom-modeline-env-setup-rust "doom-modeline-env")
(register-definition-prefixes "doom-modeline-env" '("doom-modeline-"))



(register-definition-prefixes "doom-modeline-segments" '("doom-modeline-"))


(provide 'doom-modeline-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/dashboard-20240407.12/dashboard-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/dashboard-20240407.12/dashboard-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'dashboard-open "dashboard" "\
Open (or refresh) the *dashboard* buffer.

(fn &rest _)" t)
(autoload 'dashboard-setup-startup-hook "dashboard" "\
Setup post initialization hooks unless a command line argument is provided.")
(register-definition-prefixes "dashboard" '("dashboard-"))



(register-definition-prefixes "dashboard-widgets" '("dashboard-" "recentf-list"))


(provide 'dashboard-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/counsel-20240520.1323/counsel-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/counsel-20240520.1323/counsel-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'counsel-company "counsel" "\
Complete using `company-candidates'." t)
(autoload 'counsel-irony "counsel" "\
Inline C/C++ completion using Irony." t)
(autoload 'counsel-describe-variable "counsel" "\
Forward to `describe-variable'.

Variables declared using `defcustom' are highlighted according to
`ivy-highlight-face'." t)
(autoload 'counsel-describe-function "counsel" "\
Forward to `describe-function'.

Interactive functions (i.e., commands) are highlighted according
to `ivy-highlight-face'." t)
(autoload 'counsel-describe-symbol "counsel" "\
Forward to `describe-symbol'." t)
(autoload 'counsel-set-variable "counsel" "\
Set a variable SYM, with completion.

When the selected variable is a `defcustom' with the type boolean
or radio, offer completion of all possible values.

Otherwise, offer a variant of `eval-expression', with the initial
input corresponding to the chosen variable.

With a prefix arg, restrict list to variables defined using
`defcustom'.

(fn SYM)" t)
(autoload 'counsel-apropos "counsel" "\
Show all matching symbols.
See `apropos' for further information on what is considered
a symbol and how to search for them." t)
(autoload 'counsel-info-lookup-symbol "counsel" "\
Forward SYMBOL to `info-lookup-symbol' with ivy completion.
With prefix arg MODE a query for the symbol help mode is offered.

(fn SYMBOL &optional MODE)" t)
(autoload 'counsel-M-x "counsel" "\
Ivy version of `execute-extended-command'.
Optional INITIAL-INPUT is the initial input in the minibuffer.
This function integrates with either the `amx' or `smex' package
when available, in that order of precedence.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-command-history "counsel" "\
Show the history of commands." t)
(autoload 'counsel-load-library "counsel" "\
Load a selected the Emacs Lisp library.
The libraries are offered from `load-path'." t)
(autoload 'counsel-find-library "counsel" "\
Visit a selected the Emacs Lisp library.
The libraries are offered from `load-path'." t)
(autoload 'counsel-load-theme "counsel" "\
Forward to `load-theme'.
Usable with `ivy-resume', `ivy-next-line-and-call' and
`ivy-previous-line-and-call'." t)
(autoload 'counsel-descbinds "counsel" "\
Show a list of all defined keys and their definitions.
If non-nil, show only bindings that start with PREFIX.
BUFFER defaults to the current one.

(fn &optional PREFIX BUFFER)" t)
(autoload 'counsel-describe-face "counsel" "\
Completion for `describe-face'." t)
(autoload 'counsel-faces "counsel" "\
Complete faces with preview.
Actions are provided by default for describing or customizing the
selected face." t)
(autoload 'counsel-git "counsel" "\
Find file in the current Git repository.
INITIAL-INPUT can be given as the initial minibuffer input.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-git-grep "counsel" "\
Grep for a string in the current Git repository.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
When CMD is a string, use it as a \"git grep\" command.
When CMD is non-nil, prompt for a specific \"git grep\" command.

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY CMD)" t)
(autoload 'counsel-git-stash "counsel" "\
Search through all available git stashes." t)
(autoload 'counsel-git-change-worktree "counsel" "\
Find the file corresponding to the current buffer on a different worktree." t)
(autoload 'counsel-git-checkout "counsel" "\
Call the \"git checkout\" command." t)
(autoload 'counsel-git-log "counsel" "\
Call the \"git log --grep\" shell command." t)
(autoload 'counsel-find-file "counsel" "\
Forward to `find-file'.
When INITIAL-INPUT is non-nil, use it in the minibuffer during completion.

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t)
(autoload 'counsel-dired "counsel" "\
Forward to `dired'.
When INITIAL-INPUT is non-nil, use it in the minibuffer during completion.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-recentf "counsel" "\
Find a file on `recentf-list'." t)
(autoload 'counsel-buffer-or-recentf "counsel" "\
Find a buffer visiting a file or file on `recentf-list'." t)
(autoload 'counsel-bookmark "counsel" "\
Forward to `bookmark-jump' or `bookmark-set' if bookmark doesn't exist." t)
(autoload 'counsel-bookmarked-directory "counsel" "\
Ivy interface for bookmarked directories.

With a prefix argument, this command creates a new bookmark which points to the
current value of `default-directory'." t)
(autoload 'counsel-file-register "counsel" "\
Search file in register.

You cannot use Emacs' normal register commands to create file
registers.  Instead you must use the `set-register' function like
so: `(set-register ?i \"/home/eric/.emacs.d/init.el\")'.  Now you
can use `C-x r j i' to open that file." t)
(autoload 'counsel-locate-action-extern "counsel" "\
Pass X to `xdg-open' or equivalent command via the shell.

(fn X)" t)
(autoload 'counsel-locate "counsel" "\
Call a \"locate\" style shell command.
INITIAL-INPUT can be given as the initial minibuffer input.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-tracker "counsel" nil t)
(autoload 'counsel-fzf "counsel" "\
Open a file using the fzf shell command.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
FZF-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY FZF-PROMPT)" t)
(autoload 'counsel-dpkg "counsel" "\
Call the \"dpkg\" shell command." t)
(autoload 'counsel-rpm "counsel" "\
Call the \"rpm\" shell command." t)
(autoload 'counsel-file-jump "counsel" "\
Jump to a file below the current directory.
List all files within the current directory or any of its sub-directories.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t)
(autoload 'counsel-dired-jump "counsel" "\
Jump to a directory (see `dired-jump') below the current directory.
List all sub-directories within the current directory.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY)" t)
(autoload 'counsel-ag "counsel" "\
Grep for a string in a root directory using `ag'.

By default, the root directory is the first directory containing
a .git subdirectory.

INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
EXTRA-AG-ARGS, if non-nil, is appended to `counsel-ag-base-command'.
AG-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.
CALLER is passed to `ivy-read'.

With a `\\[universal-argument]' prefix argument, prompt for INITIAL-DIRECTORY.
With a `\\[universal-argument] \\[universal-argument]' prefix argument, prompt additionally for EXTRA-AG-ARGS.

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY EXTRA-AG-ARGS AG-PROMPT &key CALLER)" t)
(autoload 'counsel-pt "counsel" "\
Grep for a string in the current directory using pt.
INITIAL-INPUT can be given as the initial minibuffer input.
This uses `counsel-ag' with `counsel-pt-base-command' instead of
`counsel-ag-base-command'.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-ack "counsel" "\
Grep for a string in the current directory using ack.
INITIAL-INPUT can be given as the initial minibuffer input.
This uses `counsel-ag' with `counsel-ack-base-command' replacing
`counsel-ag-base-command'.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-rg "counsel" "\
Grep for a string in the current directory using `rg'.
INITIAL-INPUT can be given as the initial minibuffer input.
INITIAL-DIRECTORY, if non-nil, is used as the root directory for search.
EXTRA-RG-ARGS string, if non-nil, is appended to `counsel-rg-base-command'.
RG-PROMPT, if non-nil, is passed as `ivy-read' prompt argument.

Example input with inclusion and exclusion file patterns:
    require i -- -g*.el

(fn &optional INITIAL-INPUT INITIAL-DIRECTORY EXTRA-RG-ARGS RG-PROMPT)" t)
(autoload 'counsel-grep "counsel" "\
Grep for a string in the file visited by the current buffer.
When non-nil, INITIAL-INPUT is the initial search pattern.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-grep-backward "counsel" "\
Grep for a string in the file visited by the current buffer going
backward similar to `swiper-backward'. When non-nil, INITIAL-INPUT is
the initial search pattern.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-grep-or-swiper "counsel" "\
Call `swiper' for small buffers and `counsel-grep' for large ones.
When non-nil, INITIAL-INPUT is the initial search pattern.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-grep-or-swiper-backward "counsel" "\
Call `swiper-backward' for small buffers and `counsel-grep-backward' for
large ones.  When non-nil, INITIAL-INPUT is the initial search pattern.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel-recoll "counsel" "\
Search for a string in the recoll database.
You'll be given a list of files that match.
Selecting a file will launch `swiper' for that file.
INITIAL-INPUT can be given as the initial minibuffer input.

(fn &optional INITIAL-INPUT)" t)
(autoload 'counsel--org-get-tags "counsel")
(autoload 'counsel-org-tag "counsel" "\
Add or remove tags in `org-mode'." t)
(autoload 'counsel-org-tag-agenda "counsel" "\
Set tags for the current agenda item." t)
(defalias 'counsel-org-goto #'counsel-outline)
(autoload 'counsel-org-goto-all "counsel" "\
Go to a different location in any org file." t)
(autoload 'counsel-org-file "counsel" "\
Browse all attachments for current Org file." t)
(autoload 'counsel-org-entity "counsel" "\
Complete Org entities using Ivy." t)
(autoload 'counsel-org-capture "counsel" "\
Capture something." t)
(autoload 'counsel-org-agenda-headlines "counsel" "\
Choose from headers of `org-mode' files in the agenda." t)
(autoload 'counsel-org-link "counsel" "\
Insert a link to an headline with completion." t)
(autoload 'counsel-mark-ring "counsel" "\
Browse `mark-ring' interactively.
Obeys `widen-automatically', which see." t)
(autoload 'counsel-evil-marks "counsel" "\
Ivy replacement for `evil-show-marks'.
By default, this function respects `counsel-evil-marks-exclude-registers'.
When ARG is non-nil, display all active evil registers.

(fn &optional ARG)" t)
(autoload 'counsel-package "counsel" "\
Install or delete packages.

Packages not currently installed are prefixed with \"+\", and
selecting one of these will try to install it.
Packages currently installed are prefixed with \"-\", and
selecting one of these will try to delete it.

Additional actions:\\<ivy-minibuffer-map>

  \\[ivy-dispatching-done] d: Describe package
  \\[ivy-dispatching-done] h: Visit package's homepage" t)
(autoload 'counsel-tmm "counsel" "\
Text-mode emulation of looking and choosing from a menu bar." t)
(autoload 'counsel-yank-pop "counsel" "\
Ivy replacement for `yank-pop'.
With a plain prefix argument (\\[universal-argument]),
temporarily toggle the value of `counsel-yank-pop-after-point'.
Any other value of ARG has the same meaning as in `yank-pop', but
`counsel-yank-pop-preselect-last' determines its default value.
See also `counsel-yank-pop-filter' for how to filter candidates.

Note: Duplicate elements of `kill-ring' are always deleted.

(fn &optional ARG)" t)
(autoload 'counsel-register "counsel" "\
Interactively choose a register." t)
(autoload 'counsel-evil-registers "counsel" "\
Ivy replacement for `evil-show-registers'." t)
(autoload 'counsel-imenu "counsel" "\
Jump to a buffer position indexed by imenu." t)
(autoload 'counsel-list-processes "counsel" "\
Offer completion for `process-list'.
The default action deletes the selected process.
An extra action allows to switch to the process buffer." t)
(autoload 'counsel-minibuffer-history "counsel" "\
Browse minibuffer history." t)
(autoload 'counsel-esh-history "counsel" "\
Browse Eshell history." t)
(autoload 'counsel-shell-history "counsel" "\
Browse shell history." t)
(autoload 'counsel-slime-repl-history "counsel" "\
Browse Slime REPL history." t)
(autoload 'counsel-hydra-heads "counsel" "\
Call a head of the current/last hydra." t)
(autoload 'counsel-semantic "counsel" "\
Jump to a semantic tag in the current buffer." t)
(autoload 'counsel-semantic-or-imenu "counsel" nil t)
(autoload 'counsel-outline "counsel" "\
Jump to an outline heading with completion." t)
(autoload 'counsel-ibuffer "counsel" "\
Use ibuffer to switch to another buffer.
NAME specifies the name of the buffer (defaults to \"*Ibuffer*\").

(fn &optional NAME)" t)
(autoload 'counsel-switch-to-shell-buffer "counsel" "\
Switch to a shell buffer, or create one." t)
(autoload 'counsel-unicode-char "counsel" "\
Insert COUNT copies of a Unicode character at point.
COUNT defaults to 1.

(fn &optional COUNT)" t)
(autoload 'counsel-colors-emacs "counsel" "\
Show a list of all supported colors for a particular frame.

You can insert or kill the name or hexadecimal RGB value of the
selected color." t)
(autoload 'counsel-colors-web "counsel" "\
Show a list of all W3C web colors for use in CSS.

You can insert or kill the name or hexadecimal RGB value of the
selected color." t)
(autoload 'counsel-fonts "counsel" "\
Show a list of all supported font families for a particular frame.

You can insert or kill the name of the selected font." t)
(autoload 'counsel-kmacro "counsel" "\
Interactively choose and run a keyboard macro.

With prefix argument, run macro that many times.

Macros are run using the current value of `kmacro-counter-value'
and their respective counter format. Displayed next to each macro is
the counter's format and initial value.

One can use actions to copy the counter format or initial counter
value of a macro, using them for a new macro." t)
(autoload 'counsel-geiser-doc-look-up-manual "counsel" "\
Search Scheme documentation." t)
(autoload 'counsel-rhythmbox "counsel" "\
Choose a song from the Rhythmbox library to play or enqueue.

(fn &optional ARG)" t)
(autoload 'counsel-linux-app "counsel" "\
Launch a Linux desktop application, similar to Alt-<F2>.
When ARG is non-nil, ignore NoDisplay property in *.desktop files.

(fn &optional ARG)" t)
(autoload 'counsel-wmctrl "counsel" "\
Select a desktop window using wmctrl." t)
(autoload 'counsel-switch-buffer "counsel" "\
Switch to another buffer.
Display a preview of the selected ivy completion candidate buffer
in the current window." t)
(autoload 'counsel-switch-buffer-other-window "counsel" "\
Switch to another buffer in another window.
Display a preview of the selected ivy completion candidate buffer
in the current window." t)
(autoload 'counsel-compile "counsel" "\
Call `compile' completing with smart suggestions, optionally for DIR.

Additional actions:

\\{counsel-compile-map}

(fn &optional DIR)" t)
(autoload 'counsel-compile-env "counsel" "\
Update `counsel-compile-env' interactively." t)
(autoload 'counsel-minor "counsel" "\
Enable or disable minor mode.

Disabled minor modes are prefixed with \"+\", and
selecting one of these will enable it.
Enabled minor modes are prefixed with \"-\", and
selecting one of these will enable it.

Additional actions:\\<ivy-minibuffer-map>

  \\[ivy-dispatching-done] d: Go to minor mode definition
  \\[ivy-dispatching-done] h: Describe minor mode" t)
(autoload 'counsel-major "counsel" nil t)
(autoload 'counsel-compilation-errors "counsel" "\
Compilation errors." t)
(autoload 'counsel-flycheck "counsel" "\
Flycheck errors." t)
(defvar counsel-mode nil "\
Non-nil if counsel mode is enabled.
See the `counsel-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `counsel-mode'.")
(custom-autoload 'counsel-mode "counsel" nil)
(autoload 'counsel-mode "counsel" "\
Toggle Counsel mode on or off.
Turn Counsel mode on if ARG is positive, off otherwise. Counsel
mode remaps built-in emacs functions that have counsel
replacements.

Local bindings (`counsel-mode-map'):
\\{counsel-mode-map}

(fn &optional ARG)" t)
(register-definition-prefixes "counsel" '("counsel-" "ivy-function-called-at-point"))


(provide 'counsel-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/corfu-20240413.927/corfu-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/corfu-20240413.927/corfu-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'corfu-mode "corfu" "\
COmpletion in Region FUnction.

This is a minor mode.  If called interactively, toggle the `Corfu
mode' mode.  If the prefix argument is positive, enable the mode,
and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `corfu-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(put 'global-corfu-mode 'globalized-minor-mode t)
(defvar global-corfu-mode nil "\
Non-nil if Global Corfu mode is enabled.
See the `global-corfu-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-corfu-mode'.")
(custom-autoload 'global-corfu-mode "corfu" nil)
(autoload 'global-corfu-mode "corfu" "\
Toggle Corfu mode in all buffers.
With prefix ARG, enable Global Corfu mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Corfu mode is enabled in all buffers where `corfu--on' would do it.

See `corfu-mode' for more information on Corfu mode.

(fn &optional ARG)" t)
(register-definition-prefixes "corfu" '("corfu-" "global-corfu-modes"))



(defvar corfu-echo-mode nil "\
Non-nil if Corfu-Echo mode is enabled.
See the `corfu-echo-mode' command
for a description of this minor mode.")
(custom-autoload 'corfu-echo-mode "corfu-echo" nil)
(autoload 'corfu-echo-mode "corfu-echo" "\
Show candidate documentation in echo area.

This is a global minor mode.  If called interactively, toggle the
`Corfu-Echo mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='corfu-echo-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "corfu-echo" '("corfu-echo-"))



(defvar corfu-history-mode nil "\
Non-nil if Corfu-History mode is enabled.
See the `corfu-history-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `corfu-history-mode'.")
(custom-autoload 'corfu-history-mode "corfu-history" nil)
(autoload 'corfu-history-mode "corfu-history" "\
Update Corfu history and sort completions by history.

This is a global minor mode.  If called interactively, toggle the
`Corfu-History mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='corfu-history-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "corfu-history" '("corfu-history"))



(defvar corfu-indexed-mode nil "\
Non-nil if Corfu-Indexed mode is enabled.
See the `corfu-indexed-mode' command
for a description of this minor mode.")
(custom-autoload 'corfu-indexed-mode "corfu-indexed" nil)
(autoload 'corfu-indexed-mode "corfu-indexed" "\
Prefix candidates with indices.

This is a global minor mode.  If called interactively, toggle the
`Corfu-Indexed mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='corfu-indexed-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "corfu-indexed" '("corfu-indexed-"))



(autoload 'corfu-info-documentation "corfu-info" "\
Show documentation of current candidate.
If called with a prefix ARG, the buffer is persistent.

(fn &optional ARG)" t)
(autoload 'corfu-info-location "corfu-info" "\
Show location of current candidate.
If called with a prefix ARG, the buffer is persistent.

(fn &optional ARG)" t)
(register-definition-prefixes "corfu-info" '("corfu-info--"))



(defvar corfu-popupinfo-mode nil "\
Non-nil if Corfu-Popupinfo mode is enabled.
See the `corfu-popupinfo-mode' command
for a description of this minor mode.")
(custom-autoload 'corfu-popupinfo-mode "corfu-popupinfo" nil)
(autoload 'corfu-popupinfo-mode "corfu-popupinfo" "\
Corfu info popup minor mode.

This is a global minor mode.  If called interactively, toggle the
`Corfu-Popupinfo mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='corfu-popupinfo-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "corfu-popupinfo" '("corfu-popupinfo-"))



(autoload 'corfu-quick-jump "corfu-quick" "\
Jump to candidate using quick keys." t)
(autoload 'corfu-quick-insert "corfu-quick" "\
Insert candidate using quick keys." t)
(autoload 'corfu-quick-complete "corfu-quick" "\
Complete candidate using quick keys." t)
(register-definition-prefixes "corfu-quick" '("corfu-quick"))


(provide 'corfu-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/company-20240524.206/company-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/company-20240524.206/company-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'company-mode "company" "\
\"complete anything\"; is an in-buffer completion framework.

Completion starts automatically, depending on the values
`company-idle-delay' and `company-minimum-prefix-length'.

Completion can be controlled with the commands:
`company-complete-common', `company-complete-selection', `company-complete',
`company-select-next', `company-select-previous'.  If these commands are
called before `company-idle-delay', completion will also start.

Completions can be searched with `company-search-candidates' or
`company-filter-candidates'.  These can be used while completion is
inactive, as well.

The completion data is retrieved using `company-backends' and displayed
using `company-frontends'.  If you want to start a specific backend, call
it interactively or use `company-begin-backend'.

By default, the completions list is sorted alphabetically, unless the
backend chooses otherwise, or `company-transformers' changes it later.

regular keymap (`company-mode-map'):

\\{company-mode-map}
keymap during active completions (`company-active-map'):

\\{company-active-map}

This is a minor mode.  If called interactively, toggle the
`Company mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `company-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(put 'global-company-mode 'globalized-minor-mode t)
(defvar global-company-mode nil "\
Non-nil if Global Company mode is enabled.
See the `global-company-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-company-mode'.")
(custom-autoload 'global-company-mode "company" nil)
(autoload 'global-company-mode "company" "\
Toggle Company mode in all buffers.
With prefix ARG, enable Global Company mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Company mode is enabled in all buffers where `company-mode-on' would
do it.

See `company-mode' for more information on Company mode.

(fn &optional ARG)" t)
(autoload 'company-manual-begin "company" "\
Start the completion interface.

Unlike `company-complete-selection' or `company-complete', this command
doesn't cause any immediate changes to the buffer text." t)
(autoload 'company-complete "company" "\
Insert the common part of all candidates or the current selection.
The first time this is called, the common part is inserted, the second
time, or when the selection has been changed, the selected candidate is
inserted." t)
(register-definition-prefixes "company" '("company-"))



(autoload 'company-abbrev "company-abbrev" "\
`company-mode' completion backend for abbrev.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-abbrev" '("company-abbrev-insert"))



(autoload 'company-bbdb "company-bbdb" "\
`company-mode' completion backend for BBDB.

(fn COMMAND &optional ARG &rest IGNORE)" t)
(register-definition-prefixes "company-bbdb" '("company-bbdb-"))



(register-definition-prefixes "company-capf" '("company-"))



(register-definition-prefixes "company-clang" '("company-clang"))



(register-definition-prefixes "company-cmake" '("company-cmake"))



(autoload 'company-css "company-css" "\
`company-mode' completion backend for `css-mode'.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-css" '("company-css-"))



(autoload 'company-dabbrev "company-dabbrev" "\
dabbrev-like `company-mode' completion backend.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-dabbrev" '("company-dabbrev-"))



(autoload 'company-dabbrev-code "company-dabbrev-code" "\
dabbrev-like `company-mode' backend for code.
The backend looks for all symbols in the current buffer that aren't in
comments or strings.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-dabbrev-code" '("company-dabbrev-code-"))



(autoload 'company-etags "company-etags" "\
`company-mode' completion backend for etags.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-etags" '("company-etags-"))



(autoload 'company-files "company-files" "\
`company-mode' completion backend existing file names.
Completions works for proper absolute and relative files paths.
File paths with spaces are only supported inside strings.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-files" '("company-file"))



(autoload 'company-gtags "company-gtags" "\
`company-mode' completion backend for GNU Global.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-gtags" '("company-gtags-"))



(autoload 'company-ispell "company-ispell" "\
`company-mode' completion backend using Ispell.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-ispell" '("company-"))



(autoload 'company-keywords "company-keywords" "\
`company-mode' backend for programming language keywords.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-keywords" '("company-keywords-"))



(autoload 'company-nxml "company-nxml" "\
`company-mode' completion backend for `nxml-mode'.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-nxml" '("company-nxml-"))



(autoload 'company-oddmuse "company-oddmuse" "\
`company-mode' completion backend for `oddmuse-mode'.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-oddmuse" '("company-oddmuse-"))



(autoload 'company-semantic "company-semantic" "\
`company-mode' completion backend using CEDET Semantic.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-semantic" '("company-semantic-"))



(register-definition-prefixes "company-template" '("company-template-"))



(autoload 'company-tempo "company-tempo" "\
`company-mode' completion backend for tempo.

(fn COMMAND &optional ARG &rest IGNORED)" t)
(register-definition-prefixes "company-tempo" '("company-tempo-"))



(autoload 'company-tng-frontend "company-tng" "\
When the user changes the selection at least once, this
frontend will display the candidate in the buffer as if it's
already there and any key outside of `company-active-map' will
confirm the selection and finish the completion.

(fn COMMAND)")
(define-obsolete-function-alias 'company-tng-configure-default 'company-tng-mode "0.10.0" "Applies the default configuration to enable company-tng.")
(defvar company-tng-mode nil "\
Non-nil if Company-Tng mode is enabled.
See the `company-tng-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `company-tng-mode'.")
(custom-autoload 'company-tng-mode "company-tng" nil)
(autoload 'company-tng-mode "company-tng" "\
This minor mode enables `company-tng-frontend'.

This is a global minor mode.  If called interactively, toggle the
`Company-Tng mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='company-tng-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "company-tng" '("company-tng-"))



(autoload 'company-yasnippet "company-yasnippet" "\
`company-mode' backend for `yasnippet'.

This backend should be used with care, because as long as there are
snippets defined for the current major mode, this backend will always
shadow backends that come after it.  Recommended usages:

* In a buffer-local value of `company-backends', grouped with a backend or
  several that provide actual text completions.

  (add-hook \\='js-mode-hook
            (lambda ()
              (set (make-local-variable \\='company-backends)
                   \\='((company-dabbrev-code company-yasnippet)))))

* After keyword `:with', grouped with other backends.

  (push \\='(company-semantic :with company-yasnippet) company-backends)

* Not in `company-backends', just bound to a key.

  (global-set-key (kbd \"C-c y\") \\='company-yasnippet)

(fn COMMAND &optional ARG &rest IGNORE)" t)
(register-definition-prefixes "company-yasnippet" '("company-yasnippet-"))


(provide 'company-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/company-box-20240320.921/company-box-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/company-box-20240320.921/company-box-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'company-box-mode "company-box" "\
Company-box minor mode.

This is a minor mode.  If called interactively, toggle the
`company-box mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `company-box-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "company-box" '("company-box-"))



(register-definition-prefixes "company-box-doc" '("company-box-"))



(register-definition-prefixes "company-box-icons" '("company-box-icons-"))


(provide 'company-box-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/colorful-mode-1.0.0/colorful-mode-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/colorful-mode-1.0.0/colorful-mode-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'colorful-convert-and-change-color "colorful-mode" "\
Convert color to a valid format and replace color at current cursor position." t)
(autoload 'colorful-convert-and-copy-color "colorful-mode" "\
Convert color to a valid format and copy it at current cursor position." t)
(autoload 'colorful-change-or-copy-color "colorful-mode" "\
Change or copy color to a converted format at current cursor position." t)
(autoload 'colorful-add-hex-colors "colorful-mode" "\
Function for add hex colors to `colorful-color-keywords'.
This is intended to be used with `colorful-extra-color-keyword-functions'.")
(autoload 'colorful-add-color-names "colorful-mode" "\
Function for add Color names to `colorful-color-keywords'.
This is intended to be used with `colorful-extra-color-keyword-functions'.")
(autoload 'colorful-add-rgb-colors "colorful-mode" "\
Function for add CSS RGB colors to `colorful-color-keywords'.
This is intended to be used with `colorful-extra-color-keyword-functions'.")
(autoload 'colorful-add-hsl-colors "colorful-mode" "\
Function for add CSS HSL colors.
This is intended to be used with `colorful-extra-color-keyword-functions'.")
(autoload 'colorful-add-latex-colors "colorful-mode" "\
Function for add LaTex rgb/RGB/HTML/Grey colors.
This is intended to be used with `colorful-extra-color-keyword-functions'.")
(autoload 'colorful-mode "colorful-mode" "\
Preview any color in your buffer such as hex, color names, CSS rgb in real time.

This is a minor mode.  If called interactively, toggle the
`Colorful mode' mode.  If the prefix argument is positive, enable
the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `colorful-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(put 'global-colorful-mode 'globalized-minor-mode t)
(defvar global-colorful-mode nil "\
Non-nil if Global Colorful mode is enabled.
See the `global-colorful-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-colorful-mode'.")
(custom-autoload 'global-colorful-mode "colorful-mode" nil)
(autoload 'global-colorful-mode "colorful-mode" "\
Toggle Colorful mode in all buffers.
With prefix ARG, enable Global Colorful mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Colorful mode is enabled in all buffers where `colorful--turn-on'
would do it.

See `colorful-mode' for more information on Colorful mode.

`global-colorful-modes' is used to control which modes this minor mode
is used in.

(fn &optional ARG)" t)
(defvar global-colorful-modes '(mhtml-mode html-ts-mode latex-mode prog-mode) "\
Which major modes `colorful-mode' is switched on in.
This variable can be either t (all major modes), nil (no major modes),
or a list of modes and (not modes) to switch use this minor mode or
not.  For instance

  (c-mode (not message-mode mail-mode) text-mode)

means \"use this mode in all modes derived from `c-mode', don't use in
modes derived from `message-mode' or `mail-mode', but do use in other
modes derived from `text-mode'\".  An element with value t means \"use\"
and nil means \"don't use\".  There's an implicit nil at the end of the
list.")
(custom-autoload 'global-colorful-modes "colorful-mode" t)
(register-definition-prefixes "colorful-mode" '("colorful-"))


(provide 'colorful-mode-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/all-the-icons-20240108.559/all-the-icons-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/all-the-icons-20240108.559/all-the-icons-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(autoload 'all-the-icons-icon-for-dir "all-the-icons" "\
Get the formatted icon for DIR.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

Note: You want chevron, please use `all-the-icons-icon-for-dir-with-chevron'.

(fn DIR &rest ARG-OVERRIDES)")
(autoload 'all-the-icons-icon-for-file "all-the-icons" "\
Get the formatted icon for FILE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn FILE &rest ARG-OVERRIDES)")
(autoload 'all-the-icons-icon-for-mode "all-the-icons" "\
Get the formatted icon for MODE.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn MODE &rest ARG-OVERRIDES)")
(autoload 'all-the-icons-icon-for-url "all-the-icons" "\
Get the formatted icon for URL.
If an icon for URL isn't found in `all-the-icons-url-alist', a globe is used.
ARG-OVERRIDES should be a plist containining `:height',
`:v-adjust' or `:face' properties like in the normal icon
inserting functions.

(fn URL &rest ARG-OVERRIDES)")
(autoload 'all-the-icons-install-fonts "all-the-icons" "\
Helper function to download and install the latests fonts based on OS.
When PFX is non-nil, ignore the prompt and just install

(fn &optional PFX)" t)
(autoload 'all-the-icons-insert "all-the-icons" "\
Interactive icon insertion function.
When Prefix ARG is non-nil, insert the propertized icon.
When FAMILY is non-nil, limit the candidates to the icon set matching it.

(fn &optional ARG FAMILY)" t)
(register-definition-prefixes "all-the-icons" '("all-the-icons-"))


(provide 'all-the-icons-autoloads)


)
(let ((load-true-file-name "/home/adel/.emacs.d/elpa/all-the-icons-ivy-rich-20230420.1234/all-the-icons-ivy-rich-autoloads.el")(load-file-name "/home/adel/.emacs.d/elpa/all-the-icons-ivy-rich-20230420.1234/all-the-icons-ivy-rich-autoloads.el"))



(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))




(defvar all-the-icons-ivy-rich-mode nil "\
Non-nil if All-The-Icons-Ivy-Rich mode is enabled.
See the `all-the-icons-ivy-rich-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `all-the-icons-ivy-rich-mode'.")
(custom-autoload 'all-the-icons-ivy-rich-mode "all-the-icons-ivy-rich" nil)
(autoload 'all-the-icons-ivy-rich-mode "all-the-icons-ivy-rich" "\
Better experience with icons for ivy.

This is a global minor mode.  If called interactively, toggle the
`All-The-Icons-Ivy-Rich mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='all-the-icons-ivy-rich-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'all-the-icons-ivy-rich-reload "all-the-icons-ivy-rich" "\
Reload `all-the-icons-ivy-rich'." t)
(register-definition-prefixes "all-the-icons-ivy-rich" '("all-the-icons-ivy-rich-"))


(provide 'all-the-icons-ivy-rich-autoloads)


)
(defvar package-activated-list)
(setq package-activated-list
      (delete-dups
       (append
	'(yaml-mode which-key compat vertico ivy swiper s dash f shrink-path rainbow-mode php-mode org-modern async org-download org-bullets nerd-icons neotree lua-mode js2-mode ivy-rich htmlize hl-todo haskell-mode autothemer gruvbox-theme goto-chg frame-local evil evil-tutor annalist evil-collection doom-modeline dashboard counsel corfu company company-box colorful-mode all-the-icons all-the-icons-ivy-rich)
	package-activated-list)))
(progn
  (require 'info)
  (info-initialize)
  (setq Info-directory-list
	(append
	 '("/home/adel/.emacs.d/elpa/company-20240524.206" "/home/adel/.emacs.d/elpa/annalist-20240501.1201" "/home/adel/.emacs.d/elpa/evil-20240513.2118" "/home/adel/.emacs.d/elpa/haskell-mode-20240116.1718" "/home/adel/.emacs.d/elpa/dash-20240510.1327" "/home/adel/.emacs.d/elpa/ivy-20240519.1636" "/home/adel/.emacs.d/elpa/compat-29.1.4.5")
	 Info-directory-list)))

;; Local Variables:
;; version-control: never
;; no-update-autoloads: t
;; byte-compile-warnings: (not make-local)
;; End:
